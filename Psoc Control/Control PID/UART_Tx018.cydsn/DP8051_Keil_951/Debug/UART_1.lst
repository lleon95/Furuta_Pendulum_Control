C51 COMPILER V9.51   UART_1                                                                03/16/2018 17:06:23 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE UART_1
OBJECT MODULE PLACED IN .\DP8051_Keil_951\Debug\UART_1.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Cypress\PSoC Creator\4.2\PSoC Creator\import\keil\pk51\9.51\C51\BIN\c51.exe 
                    -Generated_Source\PSoC3\UART_1.c NOIV LARGE MODDP2 OMF2 VB(1) NOIP INCDIR(.,Generated_Source\PSoC3) FF(3) DB WL(2) PR(.\D
                    -P8051_Keil_951\Debug/UART_1.lst) OT(0) OJ(.\DP8051_Keil_951\Debug\UART_1.obj)

line level    source

   1          /*******************************************************************************
   2          * File Name: UART_1.c
   3          * Version 2.50
   4          *
   5          * Description:
   6          *  This file provides all API functionality of the UART component
   7          *
   8          * Note:
   9          *
  10          ********************************************************************************
  11          * Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
  12          * You may use this file only in accordance with the license, terms, conditions,
  13          * disclaimers, and limitations in the end user license agreement accompanying
  14          * the software package with which this file was provided.
  15          *******************************************************************************/
  16          
  17          #include "UART_1.h"
  18          #if (UART_1_INTERNAL_CLOCK_USED)
                  #include "UART_1_IntClock.h"
              #endif /* End UART_1_INTERNAL_CLOCK_USED */
  21          
  22          
  23          /***************************************
  24          * Global data allocation
  25          ***************************************/
  26          
  27          uint8 UART_1_initVar = 0u;
  28          
  29          #if (UART_1_TX_INTERRUPT_ENABLED && UART_1_TX_ENABLED)
                  volatile uint8 UART_1_txBuffer[UART_1_TX_BUFFER_SIZE];
                  volatile uint8 UART_1_txBufferRead = 0u;
                  uint8 UART_1_txBufferWrite = 0u;
              #endif /* (UART_1_TX_INTERRUPT_ENABLED && UART_1_TX_ENABLED) */
  34          
  35          #if (UART_1_RX_INTERRUPT_ENABLED && (UART_1_RX_ENABLED || UART_1_HD_ENABLED))
                  uint8 UART_1_errorStatus = 0u;
                  volatile uint8 UART_1_rxBuffer[UART_1_RX_BUFFER_SIZE];
                  volatile uint8 UART_1_rxBufferRead  = 0u;
                  volatile uint8 UART_1_rxBufferWrite = 0u;
                  volatile uint8 UART_1_rxBufferLoopDetect = 0u;
                  volatile uint8 UART_1_rxBufferOverflow   = 0u;
                  #if (UART_1_RXHW_ADDRESS_ENABLED)
                      volatile uint8 UART_1_rxAddressMode = UART_1_RX_ADDRESS_MODE;
                      volatile uint8 UART_1_rxAddressDetected = 0u;
                  #endif /* (UART_1_RXHW_ADDRESS_ENABLED) */
              #endif /* (UART_1_RX_INTERRUPT_ENABLED && (UART_1_RX_ENABLED || UART_1_HD_ENABLED)) */
  47          
  48          
  49          /*******************************************************************************
  50          * Function Name: UART_1_Start
  51          ********************************************************************************
  52          *
  53          * Summary:
C51 COMPILER V9.51   UART_1                                                                03/16/2018 17:06:23 PAGE 2   

  54          *  This is the preferred method to begin component operation.
  55          *  UART_1_Start() sets the initVar variable, calls the
  56          *  UART_1_Init() function, and then calls the
  57          *  UART_1_Enable() function.
  58          *
  59          * Parameters:
  60          *  None.
  61          *
  62          * Return:
  63          *  None.
  64          *
  65          * Global variables:
  66          *  The UART_1_intiVar variable is used to indicate initial
  67          *  configuration of this component. The variable is initialized to zero (0u)
  68          *  and set to one (1u) the first time UART_1_Start() is called. This
  69          *  allows for component initialization without re-initialization in all
  70          *  subsequent calls to the UART_1_Start() routine.
  71          *
  72          * Reentrant:
  73          *  No.
  74          *
  75          *******************************************************************************/
  76          void UART_1_Start(void) 
  77          {
  78   1          /* If not initialized then initialize all required hardware and software */
  79   1          if(UART_1_initVar == 0u)
  80   1          {
  81   2              UART_1_Init();
  82   2              UART_1_initVar = 1u;
  83   2          }
  84   1      
  85   1          UART_1_Enable();
  86   1      }
  87          
  88          
  89          /*******************************************************************************
  90          * Function Name: UART_1_Init
  91          ********************************************************************************
  92          *
  93          * Summary:
  94          *  Initializes or restores the component according to the customizer Configure
  95          *  dialog settings. It is not necessary to call UART_1_Init() because
  96          *  the UART_1_Start() API calls this function and is the preferred
  97          *  method to begin component operation.
  98          *
  99          * Parameters:
 100          *  None.
 101          *
 102          * Return:
 103          *  None.
 104          *
 105          *******************************************************************************/
 106          void UART_1_Init(void) 
 107          {
 108   1          #if(UART_1_RX_ENABLED || UART_1_HD_ENABLED)
              
                      #if (UART_1_RX_INTERRUPT_ENABLED)
                          /* Set RX interrupt vector and priority */
                          (void) CyIntSetVector(UART_1_RX_VECT_NUM, &UART_1_RXISR);
                          CyIntSetPriority(UART_1_RX_VECT_NUM, UART_1_RX_PRIOR_NUM);
                          UART_1_errorStatus = 0u;
                      #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
C51 COMPILER V9.51   UART_1                                                                03/16/2018 17:06:23 PAGE 3   

              
                      #if (UART_1_RXHW_ADDRESS_ENABLED)
                          UART_1_SetRxAddressMode(UART_1_RX_ADDRESS_MODE);
                          UART_1_SetRxAddress1(UART_1_RX_HW_ADDRESS1);
                          UART_1_SetRxAddress2(UART_1_RX_HW_ADDRESS2);
                      #endif /* End UART_1_RXHW_ADDRESS_ENABLED */
              
                      /* Init Count7 period */
                      UART_1_RXBITCTR_PERIOD_REG = UART_1_RXBITCTR_INIT;
                      /* Configure the Initial RX interrupt mask */
                      UART_1_RXSTATUS_MASK_REG  = UART_1_INIT_RX_INTERRUPTS_MASK;
                  #endif /* End UART_1_RX_ENABLED || UART_1_HD_ENABLED*/
 128   1      
 129   1          #if(UART_1_TX_ENABLED)
 130   1              #if (UART_1_TX_INTERRUPT_ENABLED)
                          /* Set TX interrupt vector and priority */
                          (void) CyIntSetVector(UART_1_TX_VECT_NUM, &UART_1_TXISR);
                          CyIntSetPriority(UART_1_TX_VECT_NUM, UART_1_TX_PRIOR_NUM);
                      #endif /* (UART_1_TX_INTERRUPT_ENABLED) */
 135   1      
 136   1              /* Write Counter Value for TX Bit Clk Generator*/
 137   1              #if (UART_1_TXCLKGEN_DP)
                          UART_1_TXBITCLKGEN_CTR_REG = UART_1_BIT_CENTER;
                          UART_1_TXBITCLKTX_COMPLETE_REG = ((UART_1_NUMBER_OF_DATA_BITS +
                                      UART_1_NUMBER_OF_START_BIT) * UART_1_OVER_SAMPLE_COUNT) - 1u;
                      #else
 142   1                  UART_1_TXBITCTR_PERIOD_REG = ((UART_1_NUMBER_OF_DATA_BITS +
 143   1                              UART_1_NUMBER_OF_START_BIT) * UART_1_OVER_SAMPLE_8) - 1u;
 144   1              #endif /* End UART_1_TXCLKGEN_DP */
 145   1      
 146   1              /* Configure the Initial TX interrupt mask */
 147   1              #if (UART_1_TX_INTERRUPT_ENABLED)
                          UART_1_TXSTATUS_MASK_REG = UART_1_TX_STS_FIFO_EMPTY;
                      #else
 150   1                  UART_1_TXSTATUS_MASK_REG = UART_1_INIT_TX_INTERRUPTS_MASK;
 151   1              #endif /*End UART_1_TX_INTERRUPT_ENABLED*/
 152   1      
 153   1          #endif /* End UART_1_TX_ENABLED */
 154   1      
 155   1          #if(UART_1_PARITY_TYPE_SW)  /* Write Parity to Control Register */
                      UART_1_WriteControlRegister( \
                          (UART_1_ReadControlRegister() & (uint8)~UART_1_CTRL_PARITY_TYPE_MASK) | \
                          (uint8)(UART_1_PARITY_TYPE << UART_1_CTRL_PARITY_TYPE0_SHIFT) );
                  #endif /* End UART_1_PARITY_TYPE_SW */
 160   1      }
 161          
 162          
 163          /*******************************************************************************
 164          * Function Name: UART_1_Enable
 165          ********************************************************************************
 166          *
 167          * Summary:
 168          *  Activates the hardware and begins component operation. It is not necessary
 169          *  to call UART_1_Enable() because the UART_1_Start() API
 170          *  calls this function, which is the preferred method to begin component
 171          *  operation.
 172          
 173          * Parameters:
 174          *  None.
 175          *
 176          * Return:
 177          *  None.
C51 COMPILER V9.51   UART_1                                                                03/16/2018 17:06:23 PAGE 4   

 178          *
 179          * Global Variables:
 180          *  UART_1_rxAddressDetected - set to initial state (0).
 181          *
 182          *******************************************************************************/
 183          void UART_1_Enable(void) 
 184          {
 185   1          uint8 enableInterrupts;
 186   1          enableInterrupts = CyEnterCriticalSection();
 187   1      
 188   1          #if (UART_1_RX_ENABLED || UART_1_HD_ENABLED)
                      /* RX Counter (Count7) Enable */
                      UART_1_RXBITCTR_CONTROL_REG |= UART_1_CNTR_ENABLE;
              
                      /* Enable the RX Interrupt */
                      UART_1_RXSTATUS_ACTL_REG  |= UART_1_INT_ENABLE;
              
                      #if (UART_1_RX_INTERRUPT_ENABLED)
                          UART_1_EnableRxInt();
              
                          #if (UART_1_RXHW_ADDRESS_ENABLED)
                              UART_1_rxAddressDetected = 0u;
                          #endif /* (UART_1_RXHW_ADDRESS_ENABLED) */
                      #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
                  #endif /* (UART_1_RX_ENABLED || UART_1_HD_ENABLED) */
 203   1      
 204   1          #if(UART_1_TX_ENABLED)
 205   1              /* TX Counter (DP/Count7) Enable */
 206   1              #if(!UART_1_TXCLKGEN_DP)
 207   1                  UART_1_TXBITCTR_CONTROL_REG |= UART_1_CNTR_ENABLE;
 208   1              #endif /* End UART_1_TXCLKGEN_DP */
 209   1      
 210   1              /* Enable the TX Interrupt */
 211   1              UART_1_TXSTATUS_ACTL_REG |= UART_1_INT_ENABLE;
 212   1              #if (UART_1_TX_INTERRUPT_ENABLED)
                          UART_1_ClearPendingTxInt(); /* Clear history of TX_NOT_EMPTY */
                          UART_1_EnableTxInt();
                      #endif /* (UART_1_TX_INTERRUPT_ENABLED) */
 216   1           #endif /* (UART_1_TX_INTERRUPT_ENABLED) */
 217   1      
 218   1          #if (UART_1_INTERNAL_CLOCK_USED)
                      UART_1_IntClock_Start();  /* Enable the clock */
                  #endif /* (UART_1_INTERNAL_CLOCK_USED) */
 221   1      
 222   1          CyExitCriticalSection(enableInterrupts);
 223   1      }
 224          
 225          
 226          /*******************************************************************************
 227          * Function Name: UART_1_Stop
 228          ********************************************************************************
 229          *
 230          * Summary:
 231          *  Disables the UART operation.
 232          *
 233          * Parameters:
 234          *  None.
 235          *
 236          * Return:
 237          *  None.
 238          *
 239          *******************************************************************************/
C51 COMPILER V9.51   UART_1                                                                03/16/2018 17:06:23 PAGE 5   

 240          void UART_1_Stop(void) 
 241          {
 242   1          uint8 enableInterrupts;
 243   1          enableInterrupts = CyEnterCriticalSection();
 244   1      
 245   1          /* Write Bit Counter Disable */
 246   1          #if (UART_1_RX_ENABLED || UART_1_HD_ENABLED)
                      UART_1_RXBITCTR_CONTROL_REG &= (uint8) ~UART_1_CNTR_ENABLE;
                  #endif /* (UART_1_RX_ENABLED || UART_1_HD_ENABLED) */
 249   1      
 250   1          #if (UART_1_TX_ENABLED)
 251   1              #if(!UART_1_TXCLKGEN_DP)
 252   1                  UART_1_TXBITCTR_CONTROL_REG &= (uint8) ~UART_1_CNTR_ENABLE;
 253   1              #endif /* (!UART_1_TXCLKGEN_DP) */
 254   1          #endif /* (UART_1_TX_ENABLED) */
 255   1      
 256   1          #if (UART_1_INTERNAL_CLOCK_USED)
                      UART_1_IntClock_Stop();   /* Disable the clock */
                  #endif /* (UART_1_INTERNAL_CLOCK_USED) */
 259   1      
 260   1          /* Disable internal interrupt component */
 261   1          #if (UART_1_RX_ENABLED || UART_1_HD_ENABLED)
                      UART_1_RXSTATUS_ACTL_REG  &= (uint8) ~UART_1_INT_ENABLE;
              
                      #if (UART_1_RX_INTERRUPT_ENABLED)
                          UART_1_DisableRxInt();
                      #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
                  #endif /* (UART_1_RX_ENABLED || UART_1_HD_ENABLED) */
 268   1      
 269   1          #if (UART_1_TX_ENABLED)
 270   1              UART_1_TXSTATUS_ACTL_REG &= (uint8) ~UART_1_INT_ENABLE;
 271   1      
 272   1              #if (UART_1_TX_INTERRUPT_ENABLED)
                          UART_1_DisableTxInt();
                      #endif /* (UART_1_TX_INTERRUPT_ENABLED) */
 275   1          #endif /* (UART_1_TX_ENABLED) */
 276   1      
 277   1          CyExitCriticalSection(enableInterrupts);
 278   1      }
 279          
 280          
 281          /*******************************************************************************
 282          * Function Name: UART_1_ReadControlRegister
 283          ********************************************************************************
 284          *
 285          * Summary:
 286          *  Returns the current value of the control register.
 287          *
 288          * Parameters:
 289          *  None.
 290          *
 291          * Return:
 292          *  Contents of the control register.
 293          *
 294          *******************************************************************************/
 295          uint8 UART_1_ReadControlRegister(void) 
 296          {
 297   1          #if (UART_1_CONTROL_REG_REMOVED)
 298   1              return(0u);
 299   1          #else
                      return(UART_1_CONTROL_REG);
                  #endif /* (UART_1_CONTROL_REG_REMOVED) */
C51 COMPILER V9.51   UART_1                                                                03/16/2018 17:06:23 PAGE 6   

 302   1      }
 303          
 304          
 305          /*******************************************************************************
 306          * Function Name: UART_1_WriteControlRegister
 307          ********************************************************************************
 308          *
 309          * Summary:
 310          *  Writes an 8-bit value into the control register
 311          *
 312          * Parameters:
 313          *  control:  control register value
 314          *
 315          * Return:
 316          *  None.
 317          *
 318          *******************************************************************************/
 319          void  UART_1_WriteControlRegister(uint8 control) 
 320          {
 321   1          #if (UART_1_CONTROL_REG_REMOVED)
 322   1              if(0u != control)
 323   1              {
 324   2                  /* Suppress compiler warning */
 325   2              }
 326   1          #else
                     UART_1_CONTROL_REG = control;
                  #endif /* (UART_1_CONTROL_REG_REMOVED) */
 329   1      }
 330          
 331          
 332          #if(UART_1_RX_ENABLED || UART_1_HD_ENABLED)
                  /*******************************************************************************
                  * Function Name: UART_1_SetRxInterruptMode
                  ********************************************************************************
                  *
                  * Summary:
                  *  Configures the RX interrupt sources enabled.
                  *
                  * Parameters:
                  *  IntSrc:  Bit field containing the RX interrupts to enable. Based on the 
                  *  bit-field arrangement of the status register. This value must be a 
                  *  combination of status register bit-masks shown below:
                  *      UART_1_RX_STS_FIFO_NOTEMPTY    Interrupt on byte received.
                  *      UART_1_RX_STS_PAR_ERROR        Interrupt on parity error.
                  *      UART_1_RX_STS_STOP_ERROR       Interrupt on stop error.
                  *      UART_1_RX_STS_BREAK            Interrupt on break.
                  *      UART_1_RX_STS_OVERRUN          Interrupt on overrun error.
                  *      UART_1_RX_STS_ADDR_MATCH       Interrupt on address match.
                  *      UART_1_RX_STS_MRKSPC           Interrupt on address detect.
                  *
                  * Return:
                  *  None.
                  *
                  * Theory:
                  *  Enables the output of specific status bits to the interrupt controller
                  *
                  *******************************************************************************/
                  void UART_1_SetRxInterruptMode(uint8 intSrc) 
                  {
                      UART_1_RXSTATUS_MASK_REG  = intSrc;
                  }
              
C51 COMPILER V9.51   UART_1                                                                03/16/2018 17:06:23 PAGE 7   

              
                  /*******************************************************************************
                  * Function Name: UART_1_ReadRxData
                  ********************************************************************************
                  *
                  * Summary:
                  *  Returns the next byte of received data. This function returns data without
                  *  checking the status. You must check the status separately.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  Received data from RX register
                  *
                  * Global Variables:
                  *  UART_1_rxBuffer - RAM buffer pointer for save received data.
                  *  UART_1_rxBufferWrite - cyclic index for write to rxBuffer,
                  *     checked to identify new data.
                  *  UART_1_rxBufferRead - cyclic index for read from rxBuffer,
                  *     incremented after each byte has been read from buffer.
                  *  UART_1_rxBufferLoopDetect - cleared if loop condition was detected
                  *     in RX ISR.
                  *
                  * Reentrant:
                  *  No.
                  *
                  *******************************************************************************/
                  uint8 UART_1_ReadRxData(void) 
                  {
                      uint8 rxData;
              
                  #if (UART_1_RX_INTERRUPT_ENABLED)
              
                      uint8 locRxBufferRead;
                      uint8 locRxBufferWrite;
              
                      /* Protect variables that could change on interrupt */
                      UART_1_DisableRxInt();
              
                      locRxBufferRead  = UART_1_rxBufferRead;
                      locRxBufferWrite = UART_1_rxBufferWrite;
              
                      if( (UART_1_rxBufferLoopDetect != 0u) || (locRxBufferRead != locRxBufferWrite) )
                      {
                          rxData = UART_1_rxBuffer[locRxBufferRead];
                          locRxBufferRead++;
              
                          if(locRxBufferRead >= UART_1_RX_BUFFER_SIZE)
                          {
                              locRxBufferRead = 0u;
                          }
                          /* Update the real pointer */
                          UART_1_rxBufferRead = locRxBufferRead;
              
                          if(UART_1_rxBufferLoopDetect != 0u)
                          {
                              UART_1_rxBufferLoopDetect = 0u;
                              #if ((UART_1_RX_INTERRUPT_ENABLED) && (UART_1_FLOW_CONTROL != 0u))
                                  /* When Hardware Flow Control selected - return RX mask */
                                  #if( UART_1_HD_ENABLED )
                                      if((UART_1_CONTROL_REG & UART_1_CTRL_HD_SEND) == 0u)
C51 COMPILER V9.51   UART_1                                                                03/16/2018 17:06:23 PAGE 8   

                                      {   /* In Half duplex mode return RX mask only in RX
                                          *  configuration set, otherwise
                                          *  mask will be returned in LoadRxConfig() API.
                                          */
                                          UART_1_RXSTATUS_MASK_REG  |= UART_1_RX_STS_FIFO_NOTEMPTY;
                                      }
                                  #else
                                      UART_1_RXSTATUS_MASK_REG  |= UART_1_RX_STS_FIFO_NOTEMPTY;
                                  #endif /* end UART_1_HD_ENABLED */
                              #endif /* ((UART_1_RX_INTERRUPT_ENABLED) && (UART_1_FLOW_CONTROL != 0u)) */
                          }
                      }
                      else
                      {   /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit */
                          rxData = UART_1_RXDATA_REG;
                      }
              
                      UART_1_EnableRxInt();
              
                  #else
              
                      /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit */
                      rxData = UART_1_RXDATA_REG;
              
                  #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
              
                      return(rxData);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_1_ReadRxStatus
                  ********************************************************************************
                  *
                  * Summary:
                  *  Returns the current state of the receiver status register and the software
                  *  buffer overflow status.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  Current state of the status register.
                  *
                  * Side Effect:
                  *  All status register bits are clear-on-read except
                  *  UART_1_RX_STS_FIFO_NOTEMPTY.
                  *  UART_1_RX_STS_FIFO_NOTEMPTY clears immediately after RX data
                  *  register read.
                  *
                  * Global Variables:
                  *  UART_1_rxBufferOverflow - used to indicate overload condition.
                  *   It set to one in RX interrupt when there isn't free space in
                  *   UART_1_rxBufferRead to write new data. This condition returned
                  *   and cleared to zero by this API as an
                  *   UART_1_RX_STS_SOFT_BUFF_OVER bit along with RX Status register
                  *   bits.
                  *
                  *******************************************************************************/
                  uint8 UART_1_ReadRxStatus(void) 
                  {
                      uint8 status;
C51 COMPILER V9.51   UART_1                                                                03/16/2018 17:06:23 PAGE 9   

              
                      status = UART_1_RXSTATUS_REG & UART_1_RX_HW_MASK;
              
                  #if (UART_1_RX_INTERRUPT_ENABLED)
                      if(UART_1_rxBufferOverflow != 0u)
                      {
                          status |= UART_1_RX_STS_SOFT_BUFF_OVER;
                          UART_1_rxBufferOverflow = 0u;
                      }
                  #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
              
                      return(status);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_1_GetChar
                  ********************************************************************************
                  *
                  * Summary:
                  *  Returns the last received byte of data. UART_1_GetChar() is
                  *  designed for ASCII characters and returns a uint8 where 1 to 255 are values
                  *  for valid characters and 0 indicates an error occurred or no data is present.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  Character read from UART RX buffer. ASCII characters from 1 to 255 are valid.
                  *  A returned zero signifies an error condition or no data available.
                  *
                  * Global Variables:
                  *  UART_1_rxBuffer - RAM buffer pointer for save received data.
                  *  UART_1_rxBufferWrite - cyclic index for write to rxBuffer,
                  *     checked to identify new data.
                  *  UART_1_rxBufferRead - cyclic index for read from rxBuffer,
                  *     incremented after each byte has been read from buffer.
                  *  UART_1_rxBufferLoopDetect - cleared if loop condition was detected
                  *     in RX ISR.
                  *
                  * Reentrant:
                  *  No.
                  *
                  *******************************************************************************/
                  uint8 UART_1_GetChar(void) 
                  {
                      uint8 rxData = 0u;
                      uint8 rxStatus;
              
                  #if (UART_1_RX_INTERRUPT_ENABLED)
                      uint8 locRxBufferRead;
                      uint8 locRxBufferWrite;
              
                      /* Protect variables that could change on interrupt */
                      UART_1_DisableRxInt();
              
                      locRxBufferRead  = UART_1_rxBufferRead;
                      locRxBufferWrite = UART_1_rxBufferWrite;
              
                      if( (UART_1_rxBufferLoopDetect != 0u) || (locRxBufferRead != locRxBufferWrite) )
                      {
                          rxData = UART_1_rxBuffer[locRxBufferRead];
C51 COMPILER V9.51   UART_1                                                                03/16/2018 17:06:23 PAGE 10  

                          locRxBufferRead++;
                          if(locRxBufferRead >= UART_1_RX_BUFFER_SIZE)
                          {
                              locRxBufferRead = 0u;
                          }
                          /* Update the real pointer */
                          UART_1_rxBufferRead = locRxBufferRead;
              
                          if(UART_1_rxBufferLoopDetect != 0u)
                          {
                              UART_1_rxBufferLoopDetect = 0u;
                              #if( (UART_1_RX_INTERRUPT_ENABLED) && (UART_1_FLOW_CONTROL != 0u) )
                                  /* When Hardware Flow Control selected - return RX mask */
                                  #if( UART_1_HD_ENABLED )
                                      if((UART_1_CONTROL_REG & UART_1_CTRL_HD_SEND) == 0u)
                                      {   /* In Half duplex mode return RX mask only if
                                          *  RX configuration set, otherwise
                                          *  mask will be returned in LoadRxConfig() API.
                                          */
                                          UART_1_RXSTATUS_MASK_REG |= UART_1_RX_STS_FIFO_NOTEMPTY;
                                      }
                                  #else
                                      UART_1_RXSTATUS_MASK_REG |= UART_1_RX_STS_FIFO_NOTEMPTY;
                                  #endif /* end UART_1_HD_ENABLED */
                              #endif /* UART_1_RX_INTERRUPT_ENABLED and Hardware flow control*/
                          }
              
                      }
                      else
                      {   rxStatus = UART_1_RXSTATUS_REG;
                          if((rxStatus & UART_1_RX_STS_FIFO_NOTEMPTY) != 0u)
                          {   /* Read received data from FIFO */
                              rxData = UART_1_RXDATA_REG;
                              /*Check status on error*/
                              if((rxStatus & (UART_1_RX_STS_BREAK | UART_1_RX_STS_PAR_ERROR |
                                              UART_1_RX_STS_STOP_ERROR | UART_1_RX_STS_OVERRUN)) != 0u)
                              {
                                  rxData = 0u;
                              }
                          }
                      }
              
                      UART_1_EnableRxInt();
              
                  #else
              
                      rxStatus =UART_1_RXSTATUS_REG;
                      if((rxStatus & UART_1_RX_STS_FIFO_NOTEMPTY) != 0u)
                      {
                          /* Read received data from FIFO */
                          rxData = UART_1_RXDATA_REG;
              
                          /*Check status on error*/
                          if((rxStatus & (UART_1_RX_STS_BREAK | UART_1_RX_STS_PAR_ERROR |
                                          UART_1_RX_STS_STOP_ERROR | UART_1_RX_STS_OVERRUN)) != 0u)
                          {
                              rxData = 0u;
                          }
                      }
                  #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
              
                      return(rxData);
C51 COMPILER V9.51   UART_1                                                                03/16/2018 17:06:23 PAGE 11  

                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_1_GetByte
                  ********************************************************************************
                  *
                  * Summary:
                  *  Reads UART RX buffer immediately, returns received character and error
                  *  condition.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  MSB contains status and LSB contains UART RX data. If the MSB is nonzero,
                  *  an error has occurred.
                  *
                  * Reentrant:
                  *  No.
                  *
                  *******************************************************************************/
                  uint16 UART_1_GetByte(void) 
                  {
                      
                  #if (UART_1_RX_INTERRUPT_ENABLED)
                      uint16 locErrorStatus;
                      /* Protect variables that could change on interrupt */
                      UART_1_DisableRxInt();
                      locErrorStatus = (uint16)UART_1_errorStatus;
                      UART_1_errorStatus = 0u;
                      UART_1_EnableRxInt();
                      return ( (uint16)(locErrorStatus << 8u) | UART_1_ReadRxData() );
                  #else
                      return ( ((uint16)UART_1_ReadRxStatus() << 8u) | UART_1_ReadRxData() );
                  #endif /* UART_1_RX_INTERRUPT_ENABLED */
                      
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_1_GetRxBufferSize
                  ********************************************************************************
                  *
                  * Summary:
                  *  Returns the number of received bytes available in the RX buffer.
                  *  * RX software buffer is disabled (RX Buffer Size parameter is equal to 4): 
                  *    returns 0 for empty RX FIFO or 1 for not empty RX FIFO.
                  *  * RX software buffer is enabled: returns the number of bytes available in 
                  *    the RX software buffer. Bytes available in the RX FIFO do not take to 
                  *    account.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  uint8: Number of bytes in the RX buffer. 
                  *    Return value type depends on RX Buffer Size parameter.
                  *
                  * Global Variables:
                  *  UART_1_rxBufferWrite - used to calculate left bytes.
                  *  UART_1_rxBufferRead - used to calculate left bytes.
C51 COMPILER V9.51   UART_1                                                                03/16/2018 17:06:23 PAGE 12  

                  *  UART_1_rxBufferLoopDetect - checked to decide left bytes amount.
                  *
                  * Reentrant:
                  *  No.
                  *
                  * Theory:
                  *  Allows the user to find out how full the RX Buffer is.
                  *
                  *******************************************************************************/
                  uint8 UART_1_GetRxBufferSize(void)
                                                                          
                  {
                      uint8 size;
              
                  #if (UART_1_RX_INTERRUPT_ENABLED)
              
                      /* Protect variables that could change on interrupt */
                      UART_1_DisableRxInt();
              
                      if(UART_1_rxBufferRead == UART_1_rxBufferWrite)
                      {
                          if(UART_1_rxBufferLoopDetect != 0u)
                          {
                              size = UART_1_RX_BUFFER_SIZE;
                          }
                          else
                          {
                              size = 0u;
                          }
                      }
                      else if(UART_1_rxBufferRead < UART_1_rxBufferWrite)
                      {
                          size = (UART_1_rxBufferWrite - UART_1_rxBufferRead);
                      }
                      else
                      {
                          size = (UART_1_RX_BUFFER_SIZE - UART_1_rxBufferRead) + UART_1_rxBufferWrite;
                      }
              
                      UART_1_EnableRxInt();
              
                  #else
              
                      /* We can only know if there is data in the fifo. */
                      size = ((UART_1_RXSTATUS_REG & UART_1_RX_STS_FIFO_NOTEMPTY) != 0u) ? 1u : 0u;
              
                  #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
              
                      return(size);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_1_ClearRxBuffer
                  ********************************************************************************
                  *
                  * Summary:
                  *  Clears the receiver memory buffer and hardware RX FIFO of all received data.
                  *
                  * Parameters:
                  *  None.
                  *
C51 COMPILER V9.51   UART_1                                                                03/16/2018 17:06:23 PAGE 13  

                  * Return:
                  *  None.
                  *
                  * Global Variables:
                  *  UART_1_rxBufferWrite - cleared to zero.
                  *  UART_1_rxBufferRead - cleared to zero.
                  *  UART_1_rxBufferLoopDetect - cleared to zero.
                  *  UART_1_rxBufferOverflow - cleared to zero.
                  *
                  * Reentrant:
                  *  No.
                  *
                  * Theory:
                  *  Setting the pointers to zero makes the system believe there is no data to
                  *  read and writing will resume at address 0 overwriting any data that may
                  *  have remained in the RAM.
                  *
                  * Side Effects:
                  *  Any received data not read from the RAM or FIFO buffer will be lost.
                  *
                  *******************************************************************************/
                  void UART_1_ClearRxBuffer(void) 
                  {
                      uint8 enableInterrupts;
              
                      /* Clear the HW FIFO */
                      enableInterrupts = CyEnterCriticalSection();
                      UART_1_RXDATA_AUX_CTL_REG |= (uint8)  UART_1_RX_FIFO_CLR;
                      UART_1_RXDATA_AUX_CTL_REG &= (uint8) ~UART_1_RX_FIFO_CLR;
                      CyExitCriticalSection(enableInterrupts);
              
                  #if (UART_1_RX_INTERRUPT_ENABLED)
              
                      /* Protect variables that could change on interrupt. */
                      UART_1_DisableRxInt();
              
                      UART_1_rxBufferRead = 0u;
                      UART_1_rxBufferWrite = 0u;
                      UART_1_rxBufferLoopDetect = 0u;
                      UART_1_rxBufferOverflow = 0u;
              
                      UART_1_EnableRxInt();
              
                  #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
              
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_1_SetRxAddressMode
                  ********************************************************************************
                  *
                  * Summary:
                  *  Sets the software controlled Addressing mode used by the RX portion of the
                  *  UART.
                  *
                  * Parameters:
                  *  addressMode: Enumerated value indicating the mode of RX addressing
                  *  UART_1__B_UART__AM_SW_BYTE_BYTE -  Software Byte-by-Byte address
                  *                                               detection
                  *  UART_1__B_UART__AM_SW_DETECT_TO_BUFFER - Software Detect to Buffer
                  *                                               address detection
C51 COMPILER V9.51   UART_1                                                                03/16/2018 17:06:23 PAGE 14  

                  *  UART_1__B_UART__AM_HW_BYTE_BY_BYTE - Hardware Byte-by-Byte address
                  *                                               detection
                  *  UART_1__B_UART__AM_HW_DETECT_TO_BUFFER - Hardware Detect to Buffer
                  *                                               address detection
                  *  UART_1__B_UART__AM_NONE - No address detection
                  *
                  * Return:
                  *  None.
                  *
                  * Global Variables:
                  *  UART_1_rxAddressMode - the parameter stored in this variable for
                  *   the farther usage in RX ISR.
                  *  UART_1_rxAddressDetected - set to initial state (0).
                  *
                  *******************************************************************************/
                  void UART_1_SetRxAddressMode(uint8 addressMode)
                                                                      
                  {
                      #if(UART_1_RXHW_ADDRESS_ENABLED)
                          #if(UART_1_CONTROL_REG_REMOVED)
                              if(0u != addressMode)
                              {
                                  /* Suppress compiler warning */
                              }
                          #else /* UART_1_CONTROL_REG_REMOVED */
                              uint8 tmpCtrl;
                              tmpCtrl = UART_1_CONTROL_REG & (uint8)~UART_1_CTRL_RXADDR_MODE_MASK;
                              tmpCtrl |= (uint8)(addressMode << UART_1_CTRL_RXADDR_MODE0_SHIFT);
                              UART_1_CONTROL_REG = tmpCtrl;
              
                              #if(UART_1_RX_INTERRUPT_ENABLED && \
                                 (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH) )
                                  UART_1_rxAddressMode = addressMode;
                                  UART_1_rxAddressDetected = 0u;
                              #endif /* End UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH*/
                          #endif /* End UART_1_CONTROL_REG_REMOVED */
                      #else /* UART_1_RXHW_ADDRESS_ENABLED */
                          if(0u != addressMode)
                          {
                              /* Suppress compiler warning */
                          }
                      #endif /* End UART_1_RXHW_ADDRESS_ENABLED */
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_1_SetRxAddress1
                  ********************************************************************************
                  *
                  * Summary:
                  *  Sets the first of two hardware-detectable receiver addresses.
                  *
                  * Parameters:
                  *  address: Address #1 for hardware address detection.
                  *
                  * Return:
                  *  None.
                  *
                  *******************************************************************************/
                  void UART_1_SetRxAddress1(uint8 address) 
                  {
                      UART_1_RXADDRESS1_REG = address;
C51 COMPILER V9.51   UART_1                                                                03/16/2018 17:06:23 PAGE 15  

                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_1_SetRxAddress2
                  ********************************************************************************
                  *
                  * Summary:
                  *  Sets the second of two hardware-detectable receiver addresses.
                  *
                  * Parameters:
                  *  address: Address #2 for hardware address detection.
                  *
                  * Return:
                  *  None.
                  *
                  *******************************************************************************/
                  void UART_1_SetRxAddress2(uint8 address) 
                  {
                      UART_1_RXADDRESS2_REG = address;
                  }
              
              #endif  /* UART_1_RX_ENABLED || UART_1_HD_ENABLED*/
 883          
 884          
 885          #if( (UART_1_TX_ENABLED) || (UART_1_HD_ENABLED) )
 886              /*******************************************************************************
 887              * Function Name: UART_1_SetTxInterruptMode
 888              ********************************************************************************
 889              *
 890              * Summary:
 891              *  Configures the TX interrupt sources to be enabled, but does not enable the
 892              *  interrupt.
 893              *
 894              * Parameters:
 895              *  intSrc: Bit field containing the TX interrupt sources to enable
 896              *   UART_1_TX_STS_COMPLETE        Interrupt on TX byte complete
 897              *   UART_1_TX_STS_FIFO_EMPTY      Interrupt when TX FIFO is empty
 898              *   UART_1_TX_STS_FIFO_FULL       Interrupt when TX FIFO is full
 899              *   UART_1_TX_STS_FIFO_NOT_FULL   Interrupt when TX FIFO is not full
 900              *
 901              * Return:
 902              *  None.
 903              *
 904              * Theory:
 905              *  Enables the output of specific status bits to the interrupt controller
 906              *
 907              *******************************************************************************/
 908              void UART_1_SetTxInterruptMode(uint8 intSrc) 
 909              {
 910   1              UART_1_TXSTATUS_MASK_REG = intSrc;
 911   1          }
 912          
 913          
 914              /*******************************************************************************
 915              * Function Name: UART_1_WriteTxData
 916              ********************************************************************************
 917              *
 918              * Summary:
 919              *  Places a byte of data into the transmit buffer to be sent when the bus is
 920              *  available without checking the TX status register. You must check status
 921              *  separately.
C51 COMPILER V9.51   UART_1                                                                03/16/2018 17:06:23 PAGE 16  

 922              *
 923              * Parameters:
 924              *  txDataByte: data byte
 925              *
 926              * Return:
 927              * None.
 928              *
 929              * Global Variables:
 930              *  UART_1_txBuffer - RAM buffer pointer for save data for transmission
 931              *  UART_1_txBufferWrite - cyclic index for write to txBuffer,
 932              *    incremented after each byte saved to buffer.
 933              *  UART_1_txBufferRead - cyclic index for read from txBuffer,
 934              *    checked to identify the condition to write to FIFO directly or to TX buffer
 935              *  UART_1_initVar - checked to identify that the component has been
 936              *    initialized.
 937              *
 938              * Reentrant:
 939              *  No.
 940              *
 941              *******************************************************************************/
 942              void UART_1_WriteTxData(uint8 txDataByte) 
 943              {
 944   1              /* If not Initialized then skip this function*/
 945   1              if(UART_1_initVar != 0u)
 946   1              {
 947   2              #if (UART_1_TX_INTERRUPT_ENABLED)
              
                          /* Protect variables that could change on interrupt. */
                          UART_1_DisableTxInt();
              
                          if( (UART_1_txBufferRead == UART_1_txBufferWrite) &&
                              ((UART_1_TXSTATUS_REG & UART_1_TX_STS_FIFO_FULL) == 0u) )
                          {
                              /* Add directly to the FIFO. */
                              UART_1_TXDATA_REG = txDataByte;
                          }
                          else
                          {
                              if(UART_1_txBufferWrite >= UART_1_TX_BUFFER_SIZE)
                              {
                                  UART_1_txBufferWrite = 0u;
                              }
              
                              UART_1_txBuffer[UART_1_txBufferWrite] = txDataByte;
              
                              /* Add to the software buffer. */
                              UART_1_txBufferWrite++;
                          }
              
                          UART_1_EnableTxInt();
              
                      #else
 974   2      
 975   2                  /* Add directly to the FIFO. */
 976   2                  UART_1_TXDATA_REG = txDataByte;
 977   2      
 978   2              #endif /*(UART_1_TX_INTERRUPT_ENABLED) */
 979   2              }
 980   1          }
 981          
 982          
 983              /*******************************************************************************
C51 COMPILER V9.51   UART_1                                                                03/16/2018 17:06:23 PAGE 17  

 984              * Function Name: UART_1_ReadTxStatus
 985              ********************************************************************************
 986              *
 987              * Summary:
 988              *  Reads the status register for the TX portion of the UART.
 989              *
 990              * Parameters:
 991              *  None.
 992              *
 993              * Return:
 994              *  Contents of the status register
 995              *
 996              * Theory:
 997              *  This function reads the TX status register, which is cleared on read.
 998              *  It is up to the user to handle all bits in this return value accordingly,
 999              *  even if the bit was not enabled as an interrupt source the event happened
1000              *  and must be handled accordingly.
1001              *
1002              *******************************************************************************/
1003              uint8 UART_1_ReadTxStatus(void) 
1004              {
1005   1              return(UART_1_TXSTATUS_REG);
1006   1          }
1007          
1008          
1009              /*******************************************************************************
1010              * Function Name: UART_1_PutChar
1011              ********************************************************************************
1012              *
1013              * Summary:
1014              *  Puts a byte of data into the transmit buffer to be sent when the bus is
1015              *  available. This is a blocking API that waits until the TX buffer has room to
1016              *  hold the data.
1017              *
1018              * Parameters:
1019              *  txDataByte: Byte containing the data to transmit
1020              *
1021              * Return:
1022              *  None.
1023              *
1024              * Global Variables:
1025              *  UART_1_txBuffer - RAM buffer pointer for save data for transmission
1026              *  UART_1_txBufferWrite - cyclic index for write to txBuffer,
1027              *     checked to identify free space in txBuffer and incremented after each byte
1028              *     saved to buffer.
1029              *  UART_1_txBufferRead - cyclic index for read from txBuffer,
1030              *     checked to identify free space in txBuffer.
1031              *  UART_1_initVar - checked to identify that the component has been
1032              *     initialized.
1033              *
1034              * Reentrant:
1035              *  No.
1036              *
1037              * Theory:
1038              *  Allows the user to transmit any byte of data in a single transfer
1039              *
1040              *******************************************************************************/
1041              void UART_1_PutChar(uint8 txDataByte) 
1042              {
1043   1          #if (UART_1_TX_INTERRUPT_ENABLED)
                      /* The temporary output pointer is used since it takes two instructions
                      *  to increment with a wrap, and we can't risk doing that with the real
C51 COMPILER V9.51   UART_1                                                                03/16/2018 17:06:23 PAGE 18  

                      *  pointer and getting an interrupt in between instructions.
                      */
                      uint8 locTxBufferWrite;
                      uint8 locTxBufferRead;
              
                      do
                      { /* Block if software buffer is full, so we don't overwrite. */
              
                      #if ((UART_1_TX_BUFFER_SIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
                          /* Disable TX interrupt to protect variables from modification */
                          UART_1_DisableTxInt();
                      #endif /* (UART_1_TX_BUFFER_SIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3) */
              
                          locTxBufferWrite = UART_1_txBufferWrite;
                          locTxBufferRead  = UART_1_txBufferRead;
              
                      #if ((UART_1_TX_BUFFER_SIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
                          /* Enable interrupt to continue transmission */
                          UART_1_EnableTxInt();
                      #endif /* (UART_1_TX_BUFFER_SIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3) */
                      }
                      while( (locTxBufferWrite < locTxBufferRead) ? (locTxBufferWrite == (locTxBufferRead - 1u)) :
                                              ((locTxBufferWrite - locTxBufferRead) ==
                                              (uint8)(UART_1_TX_BUFFER_SIZE - 1u)) );
              
                      if( (locTxBufferRead == locTxBufferWrite) &&
                          ((UART_1_TXSTATUS_REG & UART_1_TX_STS_FIFO_FULL) == 0u) )
                      {
                          /* Add directly to the FIFO */
                          UART_1_TXDATA_REG = txDataByte;
                      }
                      else
                      {
                          if(locTxBufferWrite >= UART_1_TX_BUFFER_SIZE)
                          {
                              locTxBufferWrite = 0u;
                          }
                          /* Add to the software buffer. */
                          UART_1_txBuffer[locTxBufferWrite] = txDataByte;
                          locTxBufferWrite++;
              
                          /* Finally, update the real output pointer */
                      #if ((UART_1_TX_BUFFER_SIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
                          UART_1_DisableTxInt();
                      #endif /* (UART_1_TX_BUFFER_SIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3) */
              
                          UART_1_txBufferWrite = locTxBufferWrite;
              
                      #if ((UART_1_TX_BUFFER_SIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
                          UART_1_EnableTxInt();
                      #endif /* (UART_1_TX_BUFFER_SIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3) */
              
                          if(0u != (UART_1_TXSTATUS_REG & UART_1_TX_STS_FIFO_EMPTY))
                          {
                              /* Trigger TX interrupt to send software buffer */
                              UART_1_SetPendingTxInt();
                          }
                      }
              
                  #else
1106   1      
1107   1              while((UART_1_TXSTATUS_REG & UART_1_TX_STS_FIFO_FULL) != 0u)
C51 COMPILER V9.51   UART_1                                                                03/16/2018 17:06:23 PAGE 19  

1108   1              {
1109   2                  /* Wait for room in the FIFO */
1110   2              }
1111   1      
1112   1              /* Add directly to the FIFO */
1113   1              UART_1_TXDATA_REG = txDataByte;
1114   1      
1115   1          #endif /* UART_1_TX_INTERRUPT_ENABLED */
1116   1          }
1117          
1118          
1119              /*******************************************************************************
1120              * Function Name: UART_1_PutString
1121              ********************************************************************************
1122              *
1123              * Summary:
1124              *  Sends a NULL terminated string to the TX buffer for transmission.
1125              *
1126              * Parameters:
1127              *  string[]: Pointer to the null terminated string array residing in RAM or ROM
1128              *
1129              * Return:
1130              *  None.
1131              *
1132              * Global Variables:
1133              *  UART_1_initVar - checked to identify that the component has been
1134              *     initialized.
1135              *
1136              * Reentrant:
1137              *  No.
1138              *
1139              * Theory:
1140              *  If there is not enough memory in the TX buffer for the entire string, this
1141              *  function blocks until the last character of the string is loaded into the
1142              *  TX buffer.
1143              *
1144              *******************************************************************************/
1145              void UART_1_PutString(const char8 string[]) 
1146              {
1147   1              uint16 bufIndex = 0u;
1148   1      
1149   1              /* If not Initialized then skip this function */
1150   1              if(UART_1_initVar != 0u)
1151   1              {
1152   2                  /* This is a blocking function, it will not exit until all data is sent */
1153   2                  while(string[bufIndex] != (char8) 0)
1154   2                  {
1155   3                      UART_1_PutChar((uint8)string[bufIndex]);
1156   3                      bufIndex++;
1157   3                  }
1158   2              }
1159   1          }
1160          
1161          
1162              /*******************************************************************************
1163              * Function Name: UART_1_PutArray
1164              ********************************************************************************
1165              *
1166              * Summary:
1167              *  Places N bytes of data from a memory array into the TX buffer for
1168              *  transmission.
1169              *
C51 COMPILER V9.51   UART_1                                                                03/16/2018 17:06:23 PAGE 20  

1170              * Parameters:
1171              *  string[]: Address of the memory array residing in RAM or ROM.
1172              *  byteCount: Number of bytes to be transmitted. The type depends on TX Buffer
1173              *             Size parameter.
1174              *
1175              * Return:
1176              *  None.
1177              *
1178              * Global Variables:
1179              *  UART_1_initVar - checked to identify that the component has been
1180              *     initialized.
1181              *
1182              * Reentrant:
1183              *  No.
1184              *
1185              * Theory:
1186              *  If there is not enough memory in the TX buffer for the entire string, this
1187              *  function blocks until the last character of the string is loaded into the
1188              *  TX buffer.
1189              *
1190              *******************************************************************************/
1191              void UART_1_PutArray(const uint8 string[], uint8 byteCount)
1192                                                                              
1193              {
1194   1              uint8 bufIndex = 0u;
1195   1      
1196   1              /* If not Initialized then skip this function */
1197   1              if(UART_1_initVar != 0u)
1198   1              {
1199   2                  while(bufIndex < byteCount)
1200   2                  {
1201   3                      UART_1_PutChar(string[bufIndex]);
1202   3                      bufIndex++;
1203   3                  }
1204   2              }
1205   1          }
1206          
1207          
1208              /*******************************************************************************
1209              * Function Name: UART_1_PutCRLF
1210              ********************************************************************************
1211              *
1212              * Summary:
1213              *  Writes a byte of data followed by a carriage return (0x0D) and line feed
1214              *  (0x0A) to the transmit buffer.
1215              *
1216              * Parameters:
1217              *  txDataByte: Data byte to transmit before the carriage return and line feed.
1218              *
1219              * Return:
1220              *  None.
1221              *
1222              * Global Variables:
1223              *  UART_1_initVar - checked to identify that the component has been
1224              *     initialized.
1225              *
1226              * Reentrant:
1227              *  No.
1228              *
1229              *******************************************************************************/
1230              void UART_1_PutCRLF(uint8 txDataByte) 
1231              {
C51 COMPILER V9.51   UART_1                                                                03/16/2018 17:06:23 PAGE 21  

1232   1              /* If not Initialized then skip this function */
1233   1              if(UART_1_initVar != 0u)
1234   1              {
1235   2                  UART_1_PutChar(txDataByte);
1236   2                  UART_1_PutChar(0x0Du);
1237   2                  UART_1_PutChar(0x0Au);
1238   2              }
1239   1          }
1240          
1241          
1242              /*******************************************************************************
1243              * Function Name: UART_1_GetTxBufferSize
1244              ********************************************************************************
1245              *
1246              * Summary:
1247              *  Returns the number of bytes in the TX buffer which are waiting to be 
1248              *  transmitted.
1249              *  * TX software buffer is disabled (TX Buffer Size parameter is equal to 4): 
1250              *    returns 0 for empty TX FIFO, 1 for not full TX FIFO or 4 for full TX FIFO.
1251              *  * TX software buffer is enabled: returns the number of bytes in the TX 
1252              *    software buffer which are waiting to be transmitted. Bytes available in the
1253              *    TX FIFO do not count.
1254              *
1255              * Parameters:
1256              *  None.
1257              *
1258              * Return:
1259              *  Number of bytes used in the TX buffer. Return value type depends on the TX 
1260              *  Buffer Size parameter.
1261              *
1262              * Global Variables:
1263              *  UART_1_txBufferWrite - used to calculate left space.
1264              *  UART_1_txBufferRead - used to calculate left space.
1265              *
1266              * Reentrant:
1267              *  No.
1268              *
1269              * Theory:
1270              *  Allows the user to find out how full the TX Buffer is.
1271              *
1272              *******************************************************************************/
1273              uint8 UART_1_GetTxBufferSize(void)
1274                                                                      
1275              {
1276   1              uint8 size;
1277   1      
1278   1          #if (UART_1_TX_INTERRUPT_ENABLED)
              
                      /* Protect variables that could change on interrupt. */
                      UART_1_DisableTxInt();
              
                      if(UART_1_txBufferRead == UART_1_txBufferWrite)
                      {
                          size = 0u;
                      }
                      else if(UART_1_txBufferRead < UART_1_txBufferWrite)
                      {
                          size = (UART_1_txBufferWrite - UART_1_txBufferRead);
                      }
                      else
                      {
                          size = (UART_1_TX_BUFFER_SIZE - UART_1_txBufferRead) +
C51 COMPILER V9.51   UART_1                                                                03/16/2018 17:06:23 PAGE 22  

                                  UART_1_txBufferWrite;
                      }
              
                      UART_1_EnableTxInt();
              
                  #else
1300   1      
1301   1              size = UART_1_TXSTATUS_REG;
1302   1      
1303   1              /* Is the fifo is full. */
1304   1              if((size & UART_1_TX_STS_FIFO_FULL) != 0u)
1305   1              {
1306   2                  size = UART_1_FIFO_LENGTH;
1307   2              }
1308   1              else if((size & UART_1_TX_STS_FIFO_EMPTY) != 0u)
1309   1              {
1310   2                  size = 0u;
1311   2              }
1312   1              else
1313   1              {
1314   2                  /* We only know there is data in the fifo. */
1315   2                  size = 1u;
1316   2              }
1317   1      
1318   1          #endif /* (UART_1_TX_INTERRUPT_ENABLED) */
1319   1      
1320   1          return(size);
1321   1          }
1322          
1323          
1324              /*******************************************************************************
1325              * Function Name: UART_1_ClearTxBuffer
1326              ********************************************************************************
1327              *
1328              * Summary:
1329              *  Clears all data from the TX buffer and hardware TX FIFO.
1330              *
1331              * Parameters:
1332              *  None.
1333              *
1334              * Return:
1335              *  None.
1336              *
1337              * Global Variables:
1338              *  UART_1_txBufferWrite - cleared to zero.
1339              *  UART_1_txBufferRead - cleared to zero.
1340              *
1341              * Reentrant:
1342              *  No.
1343              *
1344              * Theory:
1345              *  Setting the pointers to zero makes the system believe there is no data to
1346              *  read and writing will resume at address 0 overwriting any data that may have
1347              *  remained in the RAM.
1348              *
1349              * Side Effects:
1350              *  Data waiting in the transmit buffer is not sent; a byte that is currently
1351              *  transmitting finishes transmitting.
1352              *
1353              *******************************************************************************/
1354              void UART_1_ClearTxBuffer(void) 
1355              {
C51 COMPILER V9.51   UART_1                                                                03/16/2018 17:06:23 PAGE 23  

1356   1              uint8 enableInterrupts;
1357   1      
1358   1              enableInterrupts = CyEnterCriticalSection();
1359   1              /* Clear the HW FIFO */
1360   1              UART_1_TXDATA_AUX_CTL_REG |= (uint8)  UART_1_TX_FIFO_CLR;
1361   1              UART_1_TXDATA_AUX_CTL_REG &= (uint8) ~UART_1_TX_FIFO_CLR;
1362   1              CyExitCriticalSection(enableInterrupts);
1363   1      
1364   1          #if (UART_1_TX_INTERRUPT_ENABLED)
              
                      /* Protect variables that could change on interrupt. */
                      UART_1_DisableTxInt();
              
                      UART_1_txBufferRead = 0u;
                      UART_1_txBufferWrite = 0u;
              
                      /* Enable Tx interrupt. */
                      UART_1_EnableTxInt();
              
                  #endif /* (UART_1_TX_INTERRUPT_ENABLED) */
1376   1          }
1377          
1378          
1379              /*******************************************************************************
1380              * Function Name: UART_1_SendBreak
1381              ********************************************************************************
1382              *
1383              * Summary:
1384              *  Transmits a break signal on the bus.
1385              *
1386              * Parameters:
1387              *  uint8 retMode:  Send Break return mode. See the following table for options.
1388              *   UART_1_SEND_BREAK - Initialize registers for break, send the Break
1389              *       signal and return immediately.
1390              *   UART_1_WAIT_FOR_COMPLETE_REINIT - Wait until break transmission is
1391              *       complete, reinitialize registers to normal transmission mode then return
1392              *   UART_1_REINIT - Reinitialize registers to normal transmission mode
1393              *       then return.
1394              *   UART_1_SEND_WAIT_REINIT - Performs both options: 
1395              *      UART_1_SEND_BREAK and UART_1_WAIT_FOR_COMPLETE_REINIT.
1396              *      This option is recommended for most cases.
1397              *
1398              * Return:
1399              *  None.
1400              *
1401              * Global Variables:
1402              *  UART_1_initVar - checked to identify that the component has been
1403              *     initialized.
1404              *  txPeriod - static variable, used for keeping TX period configuration.
1405              *
1406              * Reentrant:
1407              *  No.
1408              *
1409              * Theory:
1410              *  SendBreak function initializes registers to send 13-bit break signal. It is
1411              *  important to return the registers configuration to normal for continue 8-bit
1412              *  operation.
1413              *  There are 3 variants for this API usage:
1414              *  1) SendBreak(3) - function will send the Break signal and take care on the
1415              *     configuration returning. Function will block CPU until transmission
1416              *     complete.
1417              *  2) User may want to use blocking time if UART configured to the low speed
C51 COMPILER V9.51   UART_1                                                                03/16/2018 17:06:23 PAGE 24  

1418              *     operation
1419              *     Example for this case:
1420              *     SendBreak(0);     - initialize Break signal transmission
1421              *         Add your code here to use CPU time
1422              *     SendBreak(1);     - complete Break operation
1423              *  3) Same to 2) but user may want to initialize and use the interrupt to
1424              *     complete break operation.
1425              *     Example for this case:
1426              *     Initialize TX interrupt with "TX - On TX Complete" parameter
1427              *     SendBreak(0);     - initialize Break signal transmission
1428              *         Add your code here to use CPU time
1429              *     When interrupt appear with UART_1_TX_STS_COMPLETE status:
1430              *     SendBreak(2);     - complete Break operation
1431              *
1432              * Side Effects:
1433              *  The UART_1_SendBreak() function initializes registers to send a
1434              *  break signal.
1435              *  Break signal length depends on the break signal bits configuration.
1436              *  The register configuration should be reinitialized before normal 8-bit
1437              *  communication can continue.
1438              *
1439              *******************************************************************************/
1440              void UART_1_SendBreak(uint8 retMode) 
1441              {
1442   1      
1443   1              /* If not Initialized then skip this function*/
1444   1              if(UART_1_initVar != 0u)
1445   1              {
1446   2                  /* Set the Counter to 13-bits and transmit a 00 byte */
1447   2                  /* When that is done then reset the counter value back */
1448   2                  uint8 tmpStat;
1449   2      
1450   2              #if(UART_1_HD_ENABLED) /* Half Duplex mode*/
              
                          if( (retMode == UART_1_SEND_BREAK) ||
                              (retMode == UART_1_SEND_WAIT_REINIT ) )
                          {
                              /* CTRL_HD_SEND_BREAK - sends break bits in HD mode */
                              UART_1_WriteControlRegister(UART_1_ReadControlRegister() |
                                                                    UART_1_CTRL_HD_SEND_BREAK);
                              /* Send zeros */
                              UART_1_TXDATA_REG = 0u;
              
                              do /* Wait until transmit starts */
                              {
                                  tmpStat = UART_1_TXSTATUS_REG;
                              }
                              while((tmpStat & UART_1_TX_STS_FIFO_EMPTY) != 0u);
                          }
              
                          if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
                              (retMode == UART_1_SEND_WAIT_REINIT) )
                          {
                              do /* Wait until transmit complete */
                              {
                                  tmpStat = UART_1_TXSTATUS_REG;
                              }
                              while(((uint8)~tmpStat & UART_1_TX_STS_COMPLETE) != 0u);
                          }
              
                          if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
                              (retMode == UART_1_REINIT) ||
C51 COMPILER V9.51   UART_1                                                                03/16/2018 17:06:23 PAGE 25  

                              (retMode == UART_1_SEND_WAIT_REINIT) )
                          {
                              UART_1_WriteControlRegister(UART_1_ReadControlRegister() &
                                                            (uint8)~UART_1_CTRL_HD_SEND_BREAK);
                          }
              
                      #else /* UART_1_HD_ENABLED Full Duplex mode */
1487   2      
1488   2                  static uint8 txPeriod;
1489   2      
1490   2                  if( (retMode == UART_1_SEND_BREAK) ||
1491   2                      (retMode == UART_1_SEND_WAIT_REINIT) )
1492   2                  {
1493   3                      /* CTRL_HD_SEND_BREAK - skip to send parity bit at Break signal in Full Duplex mode */
1494   3                      #if( (UART_1_PARITY_TYPE != UART_1__B_UART__NONE_REVB) || \
1495   3                                          (UART_1_PARITY_TYPE_SW != 0u) )
                                  UART_1_WriteControlRegister(UART_1_ReadControlRegister() |
                                                                        UART_1_CTRL_HD_SEND_BREAK);
                              #endif /* End UART_1_PARITY_TYPE != UART_1__B_UART__NONE_REVB  */
1499   3      
1500   3                      #if(UART_1_TXCLKGEN_DP)
                                  txPeriod = UART_1_TXBITCLKTX_COMPLETE_REG;
                                  UART_1_TXBITCLKTX_COMPLETE_REG = UART_1_TXBITCTR_BREAKBITS;
                              #else
1504   3                          txPeriod = UART_1_TXBITCTR_PERIOD_REG;
1505   3                          UART_1_TXBITCTR_PERIOD_REG = UART_1_TXBITCTR_BREAKBITS8X;
1506   3                      #endif /* End UART_1_TXCLKGEN_DP */
1507   3      
1508   3                      /* Send zeros */
1509   3                      UART_1_TXDATA_REG = 0u;
1510   3      
1511   3                      do /* Wait until transmit starts */
1512   3                      {
1513   4                          tmpStat = UART_1_TXSTATUS_REG;
1514   4                      }
1515   3                      while((tmpStat & UART_1_TX_STS_FIFO_EMPTY) != 0u);
1516   3                  }
1517   2      
1518   2                  if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
1519   2                      (retMode == UART_1_SEND_WAIT_REINIT) )
1520   2                  {
1521   3                      do /* Wait until transmit complete */
1522   3                      {
1523   4                          tmpStat = UART_1_TXSTATUS_REG;
1524   4                      }
1525   3                      while(((uint8)~tmpStat & UART_1_TX_STS_COMPLETE) != 0u);
1526   3                  }
1527   2      
1528   2                  if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
1529   2                      (retMode == UART_1_REINIT) ||
1530   2                      (retMode == UART_1_SEND_WAIT_REINIT) )
1531   2                  {
1532   3      
1533   3                  #if(UART_1_TXCLKGEN_DP)
                              UART_1_TXBITCLKTX_COMPLETE_REG = txPeriod;
                          #else
1536   3                      UART_1_TXBITCTR_PERIOD_REG = txPeriod;
1537   3                  #endif /* End UART_1_TXCLKGEN_DP */
1538   3      
1539   3                  #if( (UART_1_PARITY_TYPE != UART_1__B_UART__NONE_REVB) || \
1540   3                       (UART_1_PARITY_TYPE_SW != 0u) )
                              UART_1_WriteControlRegister(UART_1_ReadControlRegister() &
C51 COMPILER V9.51   UART_1                                                                03/16/2018 17:06:23 PAGE 26  

                                                                    (uint8) ~UART_1_CTRL_HD_SEND_BREAK);
                          #endif /* End UART_1_PARITY_TYPE != NONE */
1544   3                  }
1545   2              #endif    /* End UART_1_HD_ENABLED */
1546   2              }
1547   1          }
1548          
1549          
1550              /*******************************************************************************
1551              * Function Name: UART_1_SetTxAddressMode
1552              ********************************************************************************
1553              *
1554              * Summary:
1555              *  Configures the transmitter to signal the next bytes is address or data.
1556              *
1557              * Parameters:
1558              *  addressMode: 
1559              *       UART_1_SET_SPACE - Configure the transmitter to send the next
1560              *                                    byte as a data.
1561              *       UART_1_SET_MARK  - Configure the transmitter to send the next
1562              *                                    byte as an address.
1563              *
1564              * Return:
1565              *  None.
1566              *
1567              * Side Effects:
1568              *  This function sets and clears UART_1_CTRL_MARK bit in the Control
1569              *  register.
1570              *
1571              *******************************************************************************/
1572              void UART_1_SetTxAddressMode(uint8 addressMode) 
1573              {
1574   1              /* Mark/Space sending enable */
1575   1              if(addressMode != 0u)
1576   1              {
1577   2              #if( UART_1_CONTROL_REG_REMOVED == 0u )
                          UART_1_WriteControlRegister(UART_1_ReadControlRegister() |
                                                                UART_1_CTRL_MARK);
                      #endif /* End UART_1_CONTROL_REG_REMOVED == 0u */
1581   2              }
1582   1              else
1583   1              {
1584   2              #if( UART_1_CONTROL_REG_REMOVED == 0u )
                          UART_1_WriteControlRegister(UART_1_ReadControlRegister() &
                                                                (uint8) ~UART_1_CTRL_MARK);
                      #endif /* End UART_1_CONTROL_REG_REMOVED == 0u */
1588   2              }
1589   1          }
1590          
1591          #endif  /* EndUART_1_TX_ENABLED */
1592          
1593          #if(UART_1_HD_ENABLED)
              
              
                  /*******************************************************************************
                  * Function Name: UART_1_LoadRxConfig
                  ********************************************************************************
                  *
                  * Summary:
                  *  Loads the receiver configuration in half duplex mode. After calling this
                  *  function, the UART is ready to receive data.
                  *
C51 COMPILER V9.51   UART_1                                                                03/16/2018 17:06:23 PAGE 27  

                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  None.
                  *
                  * Side Effects:
                  *  Valid only in half duplex mode. You must make sure that the previous
                  *  transaction is complete and it is safe to unload the transmitter
                  *  configuration.
                  *
                  *******************************************************************************/
                  void UART_1_LoadRxConfig(void) 
                  {
                      UART_1_WriteControlRegister(UART_1_ReadControlRegister() &
                                                              (uint8)~UART_1_CTRL_HD_SEND);
                      UART_1_RXBITCTR_PERIOD_REG = UART_1_HD_RXBITCTR_INIT;
              
                  #if (UART_1_RX_INTERRUPT_ENABLED)
                      /* Enable RX interrupt after set RX configuration */
                      UART_1_SetRxInterruptMode(UART_1_INIT_RX_INTERRUPTS_MASK);
                  #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_1_LoadTxConfig
                  ********************************************************************************
                  *
                  * Summary:
                  *  Loads the transmitter configuration in half duplex mode. After calling this
                  *  function, the UART is ready to transmit data.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  None.
                  *
                  * Side Effects:
                  *  Valid only in half duplex mode. You must make sure that the previous
                  *  transaction is complete and it is safe to unload the receiver configuration.
                  *
                  *******************************************************************************/
                  void UART_1_LoadTxConfig(void) 
                  {
                  #if (UART_1_RX_INTERRUPT_ENABLED)
                      /* Disable RX interrupts before set TX configuration */
                      UART_1_SetRxInterruptMode(0u);
                  #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
              
                      UART_1_WriteControlRegister(UART_1_ReadControlRegister() | UART_1_CTRL_HD_SEND);
                      UART_1_RXBITCTR_PERIOD_REG = UART_1_HD_TXBITCTR_INIT;
                  }
              
              #endif  /* UART_1_HD_ENABLED */
1660          
1661          
1662          /* [] END OF FILE */


MODULE INFORMATION:   STATIC OVERLAYABLE
C51 COMPILER V9.51   UART_1                                                                03/16/2018 17:06:23 PAGE 28  

   CODE SIZE        =    669    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     24    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
