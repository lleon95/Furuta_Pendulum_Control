C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE CYLIB
OBJECT MODULE PLACED IN .\DP8051_Keil_951\Debug\CyLib.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Cypress\PSoC Creator\4.2\PSoC Creator\import\keil\pk51\9.51\C51\BIN\c51.exe 
                    -Generated_Source\PSoC3\CyLib.c NOIV LARGE MODDP2 OMF2 VB(1) NOIP INCDIR(.,Generated_Source\PSoC3) FF(3) DB WL(2) PR(.\DP
                    -8051_Keil_951\Debug/CyLib.lst) OT(0) OJ(.\DP8051_Keil_951\Debug\CyLib.obj)

line level    source

   1          /***************************************************************************//**
   2          * \file CyLib.c
   3          * \version 5.70
   4          *
   5          * \brief Provides a system API for the clocking, interrupts and watchdog timer.
   6          *
   7          * \note Documentation of the API's in this file is located in the System
   8          * Reference Guide provided with PSoC Creator.
   9          *
  10          ********************************************************************************
  11          * \copyright
  12          * Copyright 2008-2018, Cypress Semiconductor Corporation.  All rights reserved.
  13          * You may use this file only in accordance with the license, terms, conditions,
  14          * disclaimers, and limitations in the end user license agreement accompanying
  15          * the software package with which this file was provided.
  16          *******************************************************************************/
  17          
  18          #include "CyLib.h"
  19          
  20          
  21          /*******************************************************************************
  22          * The CyResetStatus variable is used to obtain value of RESET_SR0 register after
  23          * a device reset. It is set from initialize_psoc() at the early initialization
  24          * stage. In case of IAR EW IDE, initialize_psoc() is executed before the data
  25          * sections are initialized. To avoid zeroing, CyResetStatus should be placed
  26          * to the .noinit section.
  27          *******************************************************************************/
  28          CY_NOINIT uint8 CYXDATA CyResetStatus;
  29          
  30          
  31          /* Variable Vdda */
  32          #if(CYDEV_VARIABLE_VDDA == 1)
              
                  uint8 CyScPumpEnabled = (uint8)(CYDEV_VDDA_MV < 2700);
              
              #endif  /* (CYDEV_VARIABLE_VDDA == 1) */
  37          
  38          
  39          /* Do not use these definitions directly in your application */
  40          uint32 cydelay_freq_hz  = BCLK__BUS_CLK__HZ;
  41          uint32 cydelay_freq_khz = (BCLK__BUS_CLK__HZ + 999u) / 1000u;
  42          uint8  cydelay_freq_mhz = (uint8)((BCLK__BUS_CLK__HZ + 999999u) / 1000000u);
  43          uint32 cydelay_32k_ms   = 32768u * ((BCLK__BUS_CLK__HZ + 999u) / 1000u);
  44          
  45          
  46          /* Function Prototypes */
  47          static uint8 CyUSB_PowerOnCheck(void)  ;
  48          static void CyIMO_SetTrimValue(uint8 freq) ;
  49          static void CyBusClk_Internal_SetDivider(uint16 divider);
  50          
  51          #if(CY_PSOC5)
                  static cySysTickCallback CySysTickCallbacks[CY_SYS_SYST_NUM_OF_CALLBACKS];
                  static void CySysTickServiceCallbacks(void);
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 2   

                  uint32 CySysTickInitVar = 0u;
              #endif  /* (CY_PSOC5) */
  56          
  57          
  58          #if(CY_PSOC3)
  59              CY_ISR_PROTO(IntDefaultHandler);
  60          #endif /* (CY_PSOC3) */
  61          
  62          
  63          /*******************************************************************************
  64          * Function Name: CyPLL_OUT_Start
  65          ****************************************************************************//**
  66          *
  67          *   Enables the PLL.  Optionally waits for it to become stable.
  68          *   Waits at least 250 us or until it is detected that the PLL is stable.
  69          *
  70          *   \param wait:
  71          *    \param 0: Return immediately after configuration
  72          *    \param 1: Wait for PLL lock or timeout.
  73          *
  74          * \return
  75          *   Status
  76          *    CYRET_SUCCESS - Completed successfully
  77          *    CYRET_TIMEOUT - Timeout occurred without detecting a stable clock.
  78          *     If the input source of the clock is jittery, then the lock indication
  79          *     may not occur.  However, after the timeout has expired the generated PLL
  80          *     clock can still be used.
  81          *
  82          * \sideeffect
  83          *  If wait is enabled: This function uses the Fast Time Wheel to time the wait.
  84          *  Any other use of the Fast Time Wheel will be stopped during the period of
  85          *  this function and then restored. This function also uses the 100 KHz ILO.
  86          *  If not enabled, this function will enable the 100 KHz ILO for the period of
  87          *  this function.
  88          *
  89          *  No changes to the setup of the ILO, Fast Time Wheel, Central Time Wheel or
  90          *  Once Per Second interrupt may be made by interrupt routines during the period
  91          *  of this function execution. The current operation of the ILO, Central Time
  92          *  Wheel and Once Per Second interrupt are maintained during the operation of
  93          *  this function provided the reading of the Power Manager Interrupt Status
  94          *  Register is only done using the CyPmReadStatus() function.
  95          *
  96          *******************************************************************************/
  97          cystatus CyPLL_OUT_Start(uint8 wait) 
  98          {
  99   1          cystatus status = CYRET_SUCCESS;
 100   1      
 101   1          uint8 iloEnableState;
 102   1          uint8 pmTwCfg0State;
 103   1          uint8 pmTwCfg2State;
 104   1      
 105   1      
 106   1          /* Enables PLL circuit  */
 107   1          CY_CLK_PLL_CFG0_REG |= CY_CLK_PLL_ENABLE;
 108   1      
 109   1          if(wait != 0u)
 110   1          {
 111   2              /* Save 100 KHz ILO, FTW interval, enable and interrupt enable */
 112   2              iloEnableState = CY_LIB_SLOWCLK_ILO_CR0_REG & CY_LIB_SLOWCLK_ILO_CR0_EN_100KHZ;
 113   2              pmTwCfg0State = CY_LIB_PM_TW_CFG0_REG;
 114   2              pmTwCfg2State = CY_LIB_PM_TW_CFG2_REG;
 115   2      
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 3   

 116   2              CyPmFtwSetInterval(CY_CLK_PLL_FTW_INTERVAL);
 117   2      
 118   2              status = CYRET_TIMEOUT;
 119   2      
 120   2              while(0u == (CY_PM_FTW_INT & CyPmReadStatus(CY_PM_FTW_INT)))
 121   2              {
 122   3                  /* Wait for interrupt status */
 123   3                  if(0u != (CY_CLK_PLL_SR_REG & CY_CLK_PLL_LOCK_STATUS))
 124   3                  {
 125   4                      if(0u != (CY_CLK_PLL_SR_REG & CY_CLK_PLL_LOCK_STATUS))
 126   4                      {
 127   5                          status = CYRET_SUCCESS;
 128   5                          break;
 129   5                      }
 130   4                  }
 131   3              }
 132   2      
 133   2              /* Restore 100 KHz ILO, FTW interval, enable and interrupt enable */
 134   2              if(0u == iloEnableState)
 135   2              {
 136   3                  CyILO_Stop100K();
 137   3              }
 138   2      
 139   2              CY_LIB_PM_TW_CFG0_REG = pmTwCfg0State;
 140   2              CY_LIB_PM_TW_CFG2_REG = pmTwCfg2State;
 141   2          }
 142   1      
 143   1          return(status);
 144   1      }
 145          
 146          
 147          /*******************************************************************************
 148          * Function Name: CyPLL_OUT_Stop
 149          ****************************************************************************//**
 150          *
 151          *  Disables the PLL.
 152          *
 153          *******************************************************************************/
 154          void CyPLL_OUT_Stop(void) 
 155          {
 156   1          CY_CLK_PLL_CFG0_REG &= ((uint8)(~CY_CLK_PLL_ENABLE));
 157   1      }
 158          
 159          
 160          /*******************************************************************************
 161          * Function Name: CyPLL_OUT_SetPQ
 162          ****************************************************************************//**
 163          *
 164          *  Sets the P and Q dividers and the charge pump current.
 165          *  The Frequency Out will be P/Q * Frequency In.
 166          *  The PLL must be disabled before calling this function.
 167          *
 168          *  \param uint8 pDiv:
 169          *   Valid range [8 - 255].
 170          *
 171          *  \param uint8 qDiv:
 172          *   Valid range [1 - 16]. Input Frequency / Q must be in range of 1 to 3 MHz.
 173          
 174          *  \param uint8 current:
 175          *   Valid range [1 - 7]. Charge pump current in uA. Refer to the device TRM and
 176          *   datasheet for more information.
 177          *
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 4   

 178          * \sideeffect
 179          *  If this function execution results in the CPU clock frequency increasing,
 180          *  then the number of clock cycles the cache will wait before it samples data
 181          *  coming back from the Flash must be adjusted by calling
 182          *  CyFlash_SetWaitCycles() with an appropriate parameter. It can be optionally
 183          *  called if the CPU clock frequency is lowered in order to improve the CPU
 184          *  performance. See CyFlash_SetWaitCycles() description for more information.
 185          *
 186          *******************************************************************************/
 187          void CyPLL_OUT_SetPQ(uint8 pDiv, uint8 qDiv, uint8 current) 
 188          {
 189   1          /* Halt CPU in debug mode if PLL is enabled */
 190   1          CYASSERT(0u == (CY_CLK_PLL_CFG0_REG & CY_CLK_PLL_ENABLE));
 191   1      
 192   1          if((pDiv    >= CY_CLK_PLL_MIN_P_VALUE  ) &&
 193   1             (qDiv    <= CY_CLK_PLL_MAX_Q_VALUE  ) && (qDiv    >= CY_CLK_PLL_MIN_Q_VALUE  ) &&
 194   1             (current >= CY_CLK_PLL_MIN_CUR_VALUE) && (current <= CY_CLK_PLL_MAX_CUR_VALUE))
 195   1          {
 196   2              /* Set new values */
 197   2              CY_CLK_PLL_P_REG = pDiv;
 198   2              CY_CLK_PLL_Q_REG = ((uint8)(qDiv - 1u));
 199   2              CY_CLK_PLL_CFG1_REG = (CY_CLK_PLL_CFG1_REG & CY_CLK_PLL_CURRENT_MASK) |
 200   2                                      ((uint8)(((uint8)(current - 1u)) << CY_CLK_PLL_CURRENT_POSITION));
 201   2          }
 202   1          else
 203   1          {
 204   2              /***********************************************************************
 205   2              * Halt CPU in debug mode if:
 206   2              * - P divider is less than required
 207   2              * - Q divider is out of range
 208   2              * - pump current is out of range
 209   2              ***********************************************************************/
 210   2              CYASSERT(0u != 0u);
 211   2          }
 212   1      
 213   1      }
 214          
 215          
 216          /*******************************************************************************
 217          * Function Name: CyPLL_OUT_SetSource
 218          ****************************************************************************//**
 219          *
 220          *  Sets the input clock source to the PLL. The PLL must be disabled before
 221          *  calling this function.
 222          *
 223          *   \param source: One of the three available PLL clock sources
 224          *    \param CY_PLL_SOURCE_IMO  :   IMO
 225          *    \param CY_PLL_SOURCE_XTAL :   MHz Crystal
 226          *    \param CY_PLL_SOURCE_DSI  :   DSI
 227          *
 228          * \sideeffect
 229          *  If this function execution results in the CPU clock frequency increasing,
 230          *  then the number of clock cycles the cache will wait before it samples data
 231          *  coming back from the3 Flash must be adjusted by calling
 232          *  CyFlash_SetWaitCycles() with an appropriate parameter. It can be optionally
 233          *  called if the CPU clock frequency is lowered in order to improve the CPU
 234          *  performance. See CyFlash_SetWaitCycles() description for more information.
 235          *
 236          *******************************************************************************/
 237          void CyPLL_OUT_SetSource(uint8 source) 
 238          {
 239   1          /* Halt CPU in debug mode if PLL is enabled */
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 5   

 240   1          CYASSERT(0u == (CY_CLK_PLL_CFG0_REG & CY_CLK_PLL_ENABLE));
 241   1      
 242   1          switch(source)
 243   1          {
 244   2              case CY_PLL_SOURCE_IMO:
 245   2              case CY_PLL_SOURCE_XTAL:
 246   2              case CY_PLL_SOURCE_DSI:
 247   2                  CY_LIB_CLKDIST_CR_REG = ((CY_LIB_CLKDIST_CR_REG & CY_LIB_CLKDIST_CR_PLL_SCR_MASK) | source);
 248   2              break;
 249   2      
 250   2              default:
 251   2                  CYASSERT(0u != 0u);
 252   2              break;
 253   2          }
 254   1      }
 255          
 256          
 257          /*******************************************************************************
 258          * Function Name: CyIMO_Start
 259          ****************************************************************************//**
 260          *
 261          *  Enables the IMO. Optionally waits at least 6 us for it to settle.
 262          *
 263          *  \param uint8 wait:
 264          *   \param 0: Return immediately after configuration
 265          *   \param 1: Wait for at least 6 us for the IMO to settle.
 266          *
 267          * \sideeffect
 268          *  If wait is enabled: This function uses the Fast Time Wheel to time the wait.
 269          *  Any other use of the Fast Time Wheel will be stopped during the period of
 270          *  this function and then restored. This function also uses the 100 KHz ILO.
 271          *  If not enabled, this function will enable the 100 KHz ILO for the period of
 272          *  this function.
 273          *
 274          *  No changes to the setup of the ILO, Fast Time Wheel, Central Time Wheel or
 275          *  Once Per Second interrupt may be made by interrupt routines during the period
 276          *  of this function execution. The current operation of the ILO, Central Time
 277          *  Wheel and Once Per Second interrupt are maintained during the operation of
 278          *  this function provided the reading of the Power Manager Interrupt Status
 279          *  Register is only done using the CyPmReadStatus() function.
 280          *
 281          *******************************************************************************/
 282          void CyIMO_Start(uint8 wait) 
 283          {
 284   1          uint8 pmFtwCfg2Reg;
 285   1          uint8 pmFtwCfg0Reg;
 286   1          uint8 ilo100KhzEnable;
 287   1      
 288   1      
 289   1          CY_LIB_PM_ACT_CFG0_REG  |= CY_LIB_PM_ACT_CFG0_IMO_EN;
 290   1          CY_LIB_PM_STBY_CFG0_REG |= CY_LIB_PM_STBY_CFG0_IMO_EN;
 291   1      
 292   1          if(0u != wait)
 293   1          {
 294   2              /* Need to turn on 100KHz ILO if it happens to not already be running.*/
 295   2              ilo100KhzEnable = CY_LIB_SLOWCLK_ILO_CR0_REG & CY_LIB_SLOWCLK_ILO_CR0_EN_100KHZ;
 296   2              pmFtwCfg0Reg = CY_LIB_PM_TW_CFG0_REG;
 297   2              pmFtwCfg2Reg = CY_LIB_PM_TW_CFG2_REG;
 298   2      
 299   2              CyPmFtwSetInterval(CY_LIB_CLK_IMO_FTW_TIMEOUT);
 300   2      
 301   2              while (0u == (CY_PM_FTW_INT & CyPmReadStatus(CY_PM_FTW_INT)))
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 6   

 302   2              {
 303   3                  /* Wait for interrupt status */
 304   3              }
 305   2      
 306   2              if(0u == ilo100KhzEnable)
 307   2              {
 308   3                  CyILO_Stop100K();
 309   3              }
 310   2      
 311   2              CY_LIB_PM_TW_CFG0_REG = pmFtwCfg0Reg;
 312   2              CY_LIB_PM_TW_CFG2_REG = pmFtwCfg2Reg;
 313   2          }
 314   1      }
 315          
 316          
 317          /*******************************************************************************
 318          * Function Name: CyIMO_Stop
 319          ****************************************************************************//**
 320          *
 321          *   Disables the IMO.
 322          *
 323          *******************************************************************************/
 324          void CyIMO_Stop(void) 
 325          {
 326   1          CY_LIB_PM_ACT_CFG0_REG  &= ((uint8) (~CY_LIB_PM_ACT_CFG0_IMO_EN));
 327   1          CY_LIB_PM_STBY_CFG0_REG &= ((uint8) (~CY_LIB_PM_STBY_CFG0_IMO_EN));
 328   1      }
 329          
 330          
 331          /*******************************************************************************
 332          * Function Name: CyUSB_PowerOnCheck
 333          ****************************************************************************//**
 334          *
 335          *  Returns the USB power status value. A private function to cy_boot.
 336          *
 337          * \return
 338          *   uint8: one if the USB is enabled, 0 if not enabled.
 339          *
 340          *******************************************************************************/
 341          static uint8 CyUSB_PowerOnCheck(void)  
 342          {
 343   1          uint8 poweredOn = 0u;
 344   1      
 345   1          /* Check whether device is in Active or AltActive and if USB is powered on */
 346   1          if((((CY_PM_MODE_CSR_REG & CY_PM_MODE_CSR_MASK) == CY_PM_MODE_CSR_ACTIVE ) &&
 347   1             (0u != (CY_LIB_PM_ACT_CFG5_REG & CY_ACT_USB_ENABLED     )))  ||
 348   1             (((CY_PM_MODE_CSR_REG & CY_PM_MODE_CSR_MASK) == CY_PM_MODE_CSR_ALT_ACT) &&
 349   1             (0u != (CY_LIB_PM_STBY_CFG5_REG & CY_ALT_ACT_USB_ENABLED))))
 350   1          {
 351   2              poweredOn = 1u;
 352   2          }
 353   1      
 354   1          return (poweredOn);
 355   1      }
 356          
 357          
 358          /*******************************************************************************
 359          * Function Name: CyIMO_SetTrimValue
 360          ****************************************************************************//**
 361          *
 362          *  Sets the IMO factory trim values.
 363          *
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 7   

 364          *  uint8 freq - frequency for which trims must be set
 365          *
 366          *******************************************************************************/
 367          static void CyIMO_SetTrimValue(uint8 freq) 
 368          {
 369   1          uint8 usbPowerOn = CyUSB_PowerOnCheck();
 370   1      
 371   1          /* If USB is powered */
 372   1          if(usbPowerOn == 1u)
 373   1          {
 374   2              /* Unlock USB write */
 375   2              CY_LIB_USB_CR1_REG &= ((uint8)(~CY_LIB_USB_CLK_EN));
 376   2          }
 377   1          switch(freq)
 378   1          {
 379   2          case CY_IMO_FREQ_3MHZ:
 380   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_3MHZ_PTR);
 381   2              break;
 382   2      
 383   2          case CY_IMO_FREQ_6MHZ:
 384   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_6MHZ_PTR);
 385   2              break;
 386   2      
 387   2          case CY_IMO_FREQ_12MHZ:
 388   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_12MHZ_PTR);
 389   2              break;
 390   2      
 391   2          case CY_IMO_FREQ_24MHZ:
 392   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_24MHZ_PTR);
 393   2              break;
 394   2      
 395   2          case CY_IMO_FREQ_48MHZ:
 396   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_TR1_PTR);
 397   2              break;
 398   2      
 399   2          case CY_IMO_FREQ_62MHZ:
 400   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_67MHZ_PTR);
 401   2              break;
 402   2      
 403   2      #if(CY_PSOC5)
                  case CY_IMO_FREQ_74MHZ:
                      CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_80MHZ_PTR);
                      break;
              #endif  /* (CY_PSOC5) */
 408   2      
 409   2          case CY_IMO_FREQ_USB:
 410   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_USB_PTR);
 411   2      
 412   2              /* If USB is powered */
 413   2              if(usbPowerOn == 1u)
 414   2              {
 415   3                  /* Lock USB Oscillator */
 416   3                  CY_LIB_USB_CR1_REG |= CY_LIB_USB_CLK_EN;
 417   3              }
 418   2              break;
 419   2      
 420   2          default:
 421   2                  CYASSERT(0u != 0u);
 422   2              break;
 423   2          }
 424   1      
 425   1      }
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 8   

 426          
 427          
 428          /*******************************************************************************
 429          * Function Name: CyIMO_SetFreq
 430          ****************************************************************************//**
 431          *
 432          *  Sets the frequency of the IMO. Changes may be made while the IMO is running.
 433          *
 434          *  \param freq: Frequency of IMO operation
 435          *       CY_IMO_FREQ_3MHZ  to set  3   MHz
 436          *       CY_IMO_FREQ_6MHZ  to set  6   MHz
 437          *       CY_IMO_FREQ_12MHZ to set 12   MHz
 438          *       CY_IMO_FREQ_24MHZ to set 24   MHz
 439          *       CY_IMO_FREQ_48MHZ to set 48   MHz
 440          *       CY_IMO_FREQ_62MHZ to set 62.6 MHz
 441          *       CY_IMO_FREQ_74MHZ to set 74.7 MHz (not applicable for PSoC 3)
 442          *       CY_IMO_FREQ_USB   to set 24   MHz (Trimmed for USB operation)
 443          *
 444          * \sideeffect
 445          *  If this function execution results in the CPU clock frequency increasing,
 446          *  then the number of clock cycles the cache will wait before it samples data
 447          *  coming back from the Flash must be adjusted by calling
 448          *  CyFlash_SetWaitCycles() with an appropriate parameter. It can be optionally
 449          *  called if the CPU clock frequency is lowered in order to improve the CPU
 450          *  performance. See CyFlash_SetWaitCycles() description for more information.
 451          *
 452          *  When the USB setting is chosen, the USB clock locking circuit is enabled.
 453          *  Otherwise this circuit is disabled. The USB block must be powered before
 454          *  selecting the USB setting.
 455          *
 456          *******************************************************************************/
 457          void CyIMO_SetFreq(uint8 freq) 
 458          {
 459   1          uint8 currentFreq;
 460   1          uint8 nextFreq;
 461   1      
 462   1          /***************************************************************************
 463   1          * If the IMO frequency is changed,the Trim values must also be set
 464   1          * accordingly.This requires reading the current frequency. If the new
 465   1          * frequency is faster, then set a new trim and then change the frequency,
 466   1          * otherwise change the frequency and then set new trim values.
 467   1          ***************************************************************************/
 468   1      
 469   1          currentFreq = CY_LIB_FASTCLK_IMO_CR_REG & ((uint8)(~CY_LIB_FASTCLK_IMO_CR_RANGE_MASK));
 470   1      
 471   1          /* Check if requested frequency is USB. */
 472   1          nextFreq = (freq == CY_IMO_FREQ_USB) ? CY_IMO_FREQ_24MHZ : freq;
 473   1      
 474   1          switch (currentFreq)
 475   1          {
 476   2          case 0u:
 477   2              currentFreq = CY_IMO_FREQ_12MHZ;
 478   2              break;
 479   2      
 480   2          case 1u:
 481   2              currentFreq = CY_IMO_FREQ_6MHZ;
 482   2              break;
 483   2      
 484   2          case 2u:
 485   2              currentFreq = CY_IMO_FREQ_24MHZ;
 486   2              break;
 487   2      
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 9   

 488   2          case 3u:
 489   2              currentFreq = CY_IMO_FREQ_3MHZ;
 490   2              break;
 491   2      
 492   2          case 4u:
 493   2              currentFreq = CY_IMO_FREQ_48MHZ;
 494   2              break;
 495   2      
 496   2          case 5u:
 497   2              currentFreq = CY_IMO_FREQ_62MHZ;
 498   2              break;
 499   2      
 500   2      #if(CY_PSOC5)
                  case 6u:
                      currentFreq = CY_IMO_FREQ_74MHZ;
                      break;
              #endif  /* (CY_PSOC5) */
 505   2      
 506   2          default:
 507   2              CYASSERT(0u != 0u);
 508   2              break;
 509   2          }
 510   1      
 511   1          if (nextFreq >= currentFreq)
 512   1          {
 513   2              /* Set new trim first */
 514   2              CyIMO_SetTrimValue(freq);
 515   2          }
 516   1      
 517   1          /* Set usbclk_on bit when using CY_IMO_FREQ_USB, if not clear it */
 518   1          switch(freq)
 519   1          {
 520   2          case CY_IMO_FREQ_3MHZ:
 521   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 522   2                  CY_LIB_IMO_3MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
 523   2              break;
 524   2      
 525   2          case CY_IMO_FREQ_6MHZ:
 526   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 527   2                  CY_LIB_IMO_6MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
 528   2              break;
 529   2      
 530   2          case CY_IMO_FREQ_12MHZ:
 531   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 532   2                  CY_LIB_IMO_12MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
 533   2              break;
 534   2      
 535   2          case CY_IMO_FREQ_24MHZ:
 536   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 537   2                  CY_LIB_IMO_24MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
 538   2              break;
 539   2      
 540   2          case CY_IMO_FREQ_48MHZ:
 541   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 542   2                  CY_LIB_IMO_48MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
 543   2              break;
 544   2      
 545   2          case CY_IMO_FREQ_62MHZ:
 546   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 547   2                  CY_LIB_IMO_62MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
 548   2              break;
 549   2      
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 10  

 550   2      #if(CY_PSOC5)
                  case CY_IMO_FREQ_74MHZ:
                      CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
                          CY_LIB_IMO_74MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
                      break;
              #endif  /* (CY_PSOC5) */
 556   2      
 557   2          case CY_IMO_FREQ_USB:
 558   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 559   2                  CY_LIB_IMO_24MHZ_VALUE) | CY_LIB_IMO_USBCLK_ON_SET;
 560   2              break;
 561   2      
 562   2          default:
 563   2              CYASSERT(0u != 0u);
 564   2              break;
 565   2          }
 566   1      
 567   1          /* Tu rn onIMO Doubler, if switching to CY_IMO_FREQ_USB */
 568   1          if (freq == CY_IMO_FREQ_USB)
 569   1          {
 570   2              CyIMO_EnableDoubler();
 571   2          }
 572   1          else
 573   1          {
 574   2              CyIMO_DisableDoubler();
 575   2          }
 576   1      
 577   1          if (nextFreq < currentFreq)
 578   1          {
 579   2              /* Set the trim after setting frequency */
 580   2              CyIMO_SetTrimValue(freq);
 581   2          }
 582   1      }
 583          
 584          
 585          /*******************************************************************************
 586          * Function Name: CyIMO_SetSource
 587          ****************************************************************************//**
 588          *
 589          *  Sets the source of the clock output from the IMO block.
 590          *
 591          *  The output from the IMO is by default the IMO itself. Optionally the MHz
 592          *  Crystal or DSI input can be the source of the IMO output instead.
 593          *
 594          *   \param source: CY_IMO_SOURCE_DSI to set the DSI as source.
 595          *           CY_IMO_SOURCE_XTAL to set the MHz as source.
 596          *           CY_IMO_SOURCE_IMO to set the IMO itself.
 597          *
 598          * \sideeffect
 599          *  If this function execution resulted in the CPU clock frequency increasing,
 600          *  then the number of clock cycles the cache will wait before it samples data
 601          *  coming back from the Flash must be adjusted by calling
 602          *  CyFlash_SetWaitCycles() with an appropriate parameter. It can be optionally
 603          *  called if the CPU clock frequency is lowered in order to improve the CPU
 604          *  performance. See CyFlash_SetWaitCycles() description for more information.
 605          *
 606          *******************************************************************************/
 607          void CyIMO_SetSource(uint8 source) 
 608          {
 609   1          switch(source)
 610   1          {
 611   2          case CY_IMO_SOURCE_DSI:
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 11  

 612   2              CY_LIB_CLKDIST_CR_REG     &= ((uint8)(~CY_LIB_CLKDIST_CR_IMO2X));
 613   2              CY_LIB_FASTCLK_IMO_CR_REG |= CY_LIB_FASTCLK_IMO_IMO;
 614   2              break;
 615   2      
 616   2          case CY_IMO_SOURCE_XTAL:
 617   2              CY_LIB_CLKDIST_CR_REG     |= CY_LIB_CLKDIST_CR_IMO2X;
 618   2              CY_LIB_FASTCLK_IMO_CR_REG |= CY_LIB_FASTCLK_IMO_IMO;
 619   2              break;
 620   2      
 621   2          case CY_IMO_SOURCE_IMO:
 622   2              CY_LIB_FASTCLK_IMO_CR_REG &= ((uint8)(~CY_LIB_FASTCLK_IMO_IMO));
 623   2              break;
 624   2      
 625   2          default:
 626   2              /* Incorrect source value */
 627   2              CYASSERT(0u != 0u);
 628   2              break;
 629   2          }
 630   1      }
 631          
 632          
 633          /*******************************************************************************
 634          * Function Name: CyIMO_EnableDoubler
 635          ****************************************************************************//**
 636          *
 637          *  Enables the IMO doubler.  The 2x frequency clock is used to convert a 24 MHz
 638          *  input to a 48 MHz output for use by the USB block.
 639          *
 640          *******************************************************************************/
 641          void CyIMO_EnableDoubler(void) 
 642          {
 643   1          /* Set FASTCLK_IMO_CR_PTR regigster's 4th bit */
 644   1          CY_LIB_FASTCLK_IMO_CR_REG |= CY_LIB_FASTCLK_IMO_DOUBLER;
 645   1      }
 646          
 647          
 648          /*******************************************************************************
 649          * Function Name: CyIMO_DisableDoubler
 650          ****************************************************************************//**
 651          *
 652          *   Disables the IMO doubler.
 653          *
 654          *******************************************************************************/
 655          void CyIMO_DisableDoubler(void) 
 656          {
 657   1          CY_LIB_FASTCLK_IMO_CR_REG &= ((uint8)(~CY_LIB_FASTCLK_IMO_DOUBLER));
 658   1      }
 659          
 660          
 661          /*******************************************************************************
 662          * Function Name: CyMasterClk_SetSource
 663          ****************************************************************************//**
 664          *
 665          *  Sets the source of the master clock.
 666          *
 667          *   \param source: One of the four available Master clock sources.
 668          *     CY_MASTER_SOURCE_IMO
 669          *     CY_MASTER_SOURCE_PLL
 670          *     CY_MASTER_SOURCE_XTAL
 671          *     CY_MASTER_SOURCE_DSI
 672          *
 673          * \sideeffect
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 12  

 674          *  The current source and the new source must both be running and stable before
 675          *  calling this function.
 676          *
 677          *  If this function execution resulted in the CPU clock frequency increasing,
 678          *  then the number of clock cycles the cache will wait before it samples data
 679          *  coming back from the Flash must be adjusted by calling
 680          *  CyFlash_SetWaitCycles() with an appropriate parameter. It can be optionally
 681          *  called if the CPU clock frequency is lowered in order to improve the CPU
 682          *  performance. See CyFlash_SetWaitCycles() description for more information.
 683          *
 684          *******************************************************************************/
 685          void CyMasterClk_SetSource(uint8 source) 
 686          {
 687   1          CY_LIB_CLKDIST_MSTR1_REG = (CY_LIB_CLKDIST_MSTR1_REG & MASTER_CLK_SRC_CLEAR) |
 688   1                                      (source & ((uint8)(~MASTER_CLK_SRC_CLEAR)));
 689   1      }
 690          
 691          
 692          /*******************************************************************************
 693          * Function Name: CyMasterClk_SetDivider
 694          ****************************************************************************//**
 695          *
 696          *  Sets the divider value used to generate Master Clock.
 697          *
 698          *  \param uint8 divider:
 699          *   The valid range is [0-255]. The clock will be divided by this value + 1.
 700          *   For example to divide this parameter by two should be set to 1.
 701          *
 702          * \sideeffect
 703          *  If this function execution resulted in the CPU clock frequency increasing,
 704          *  then the number of clock cycles the cache will wait before it samples data
 705          *  coming back from the Flash must be adjusted by calling
 706          *  CyFlash_SetWaitCycles() with an appropriate parameter. It can be optionally
 707          *  called if the CPU clock frequency is lowered in order to improve the CPU
 708          *  performance. See CyFlash_SetWaitCycles() description for more information.
 709          *
 710          *  When changing the Master or Bus clock divider value from div-by-n to div-by-1
 711          *  the first clock cycle output after the div-by-1 can be up to 4 ns shorter
 712          *  than the final/expected div-by-1 period.
 713          *
 714          *******************************************************************************/
 715          void CyMasterClk_SetDivider(uint8 divider) 
 716          {
 717   1          CY_LIB_CLKDIST_MSTR0_REG = divider;
 718   1      }
 719          
 720          
 721          /*******************************************************************************
 722          * Function Name: CyBusClk_Internal_SetDivider
 723          ****************************************************************************//**
 724          *
 725          *  The function used by CyBusClk_SetDivider(). For internal use only.
 726          *
 727          *   \param divider: Valid range [0-65535].
 728          *   The clock will be divided by this value + 1.
 729          *   For example, to divide this parameter by two should be set to 1.
 730          *
 731          *******************************************************************************/
 732          static void CyBusClk_Internal_SetDivider(uint16 divider)
 733          {
 734   1          /* Mask bits to enable shadow loads  */
 735   1          CY_LIB_CLKDIST_AMASK_REG &= CY_LIB_CLKDIST_AMASK_MASK;
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 13  

 736   1          CY_LIB_CLKDIST_DMASK_REG  = CY_LIB_CLKDIST_DMASK_MASK;
 737   1      
 738   1          /* Enable mask bits to enable shadow loads */
 739   1          CY_LIB_CLKDIST_BCFG2_REG |= CY_LIB_CLKDIST_BCFG2_MASK;
 740   1      
 741   1          /* Update Shadow Divider Value Register with new divider */
 742   1          CY_LIB_CLKDIST_WRK_LSB_REG = LO8(divider);
 743   1          CY_LIB_CLKDIST_WRK_MSB_REG = HI8(divider);
 744   1      
 745   1      
 746   1          /***************************************************************************
 747   1          * Copy shadow value defined in Shadow Divider Value Register
 748   1          * (CY_LIB_CLKDIST_WRK_LSB_REG and CY_LIB_CLKDIST_WRK_MSB_REG) to all
 749   1          * dividers selected in Analog and Digital Clock Mask Registers
 750   1          * (CY_LIB_CLKDIST_AMASK_REG and CY_LIB_CLKDIST_DMASK_REG).
 751   1          ***************************************************************************/
 752   1          CY_LIB_CLKDIST_LD_REG |= CY_LIB_CLKDIST_LD_LOAD;
 753   1      }
 754          
 755          
 756          /*******************************************************************************
 757          * Function Name: CyBusClk_SetDivider
 758          ****************************************************************************//**
 759          *
 760          *  Sets the divider value used to generate the Bus Clock.
 761          *
 762          *  \param divider: Valid range [0-65535]. The clock will be divided by this value + 1.
 763          *  For example, to divide this parameter by two should be set to 1.
 764          *
 765          * \sideeffect
 766          *  If this function execution resulted in the CPU clock frequency increasing,
 767          *  then the number of clock cycles the cache will wait before it samples data
 768          *  coming back from the Flash must be adjusted by calling
 769          *  CyFlash_SetWaitCycles() with an appropriate parameter. It can be optionally
 770          *  called if the CPU clock frequency is lowered in order to improve the CPU
 771          *  performance. See CyFlash_SetWaitCycles() description for more information.
 772          *
 773          *******************************************************************************/
 774          void CyBusClk_SetDivider(uint16 divider) 
 775          {
 776   1          uint8  masterClkDiv;
 777   1          uint16 busClkDiv;
 778   1          uint8 interruptState;
 779   1      
 780   1          interruptState = CyEnterCriticalSection();
 781   1      
 782   1          /* Work around to set bus clock divider value */
 783   1          busClkDiv = (uint16)((uint16)CY_LIB_CLKDIST_BCFG_MSB_REG << 8u);
 784   1          busClkDiv |= CY_LIB_CLKDIST_BCFG_LSB_REG;
 785   1      
 786   1          if ((divider == 0u) || (busClkDiv == 0u))
 787   1          {
 788   2              /* Save away master clock divider value */
 789   2              masterClkDiv = CY_LIB_CLKDIST_MSTR0_REG;
 790   2      
 791   2              if (masterClkDiv < CY_LIB_CLKDIST_MASTERCLK_DIV)
 792   2              {
 793   3                  /* Set master clock divider to 7 */
 794   3                  CyMasterClk_SetDivider(CY_LIB_CLKDIST_MASTERCLK_DIV);
 795   3              }
 796   2      
 797   2              if (divider == 0u)
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 14  

 798   2              {
 799   3                  /* Set SSS bit and divider register desired value */
 800   3                  CY_LIB_CLKDIST_BCFG2_REG |= CY_LIB_CLKDIST_BCFG2_SSS;
 801   3                  CyBusClk_Internal_SetDivider(divider);
 802   3              }
 803   2              else
 804   2              {
 805   3                  CyBusClk_Internal_SetDivider(divider);
 806   3                  CY_LIB_CLKDIST_BCFG2_REG &= ((uint8)(~CY_LIB_CLKDIST_BCFG2_SSS));
 807   3              }
 808   2      
 809   2              /* Restore master clock */
 810   2              CyMasterClk_SetDivider(masterClkDiv);
 811   2          }
 812   1          else
 813   1          {
 814   2              CyBusClk_Internal_SetDivider(divider);
 815   2          }
 816   1      
 817   1          CyExitCriticalSection(interruptState);
 818   1      }
 819          
 820          
 821          #if(CY_PSOC3)
 822          
 823              /*******************************************************************************
 824              * Function Name: CyCpuClk_SetDivider
 825              ****************************************************************************//**
 826              *
 827              *  Sets the divider value used to generate the CPU Clock. Only applicable for
 828              *  PSoC 3 parts.
 829              *
 830              *  \param divider: Valid range [0-15]. The clock will be divided by this value + 1.
 831              *  For example, to divide this parameter by two should be set to 1.
 832              *
 833              * \sideeffect
 834              *  If this function execution resulted in the CPU clock frequency increasing,
 835              *  then the number of clock cycles the cache will wait before it samples data
 836              *  coming back from the Flash must be adjusted by calling
 837              *  CyFlash_SetWaitCycles() with an appropriate parameter. It can be optionally
 838              *  called if the CPU clock frequency is lowered in order to improve the CPU
 839              *  performance. See CyFlash_SetWaitCycles() description for more information.
 840              *
 841              *******************************************************************************/
 842              void CyCpuClk_SetDivider(uint8 divider) 
 843              {
 844   1                  CY_LIB_CLKDIST_MSTR1_REG = (CY_LIB_CLKDIST_MSTR1_REG & CY_LIB_CLKDIST_MSTR1_DIV_MASK) |
 845   1                                      ((uint8)(divider << CY_LIB_CLKDIST_DIV_POSITION));
 846   1          }
 847          
 848          #endif /* (CY_PSOC3) */
 849          
 850          
 851          /*******************************************************************************
 852          * Function Name: CyUsbClk_SetSource
 853          ****************************************************************************//**
 854          *
 855          *  Sets the source of the USB clock.
 856          *
 857          *  \param source: One of the four available USB clock sources
 858          *    CY_LIB_USB_CLK_IMO2X     - IMO 2x
 859          *    CY_LIB_USB_CLK_IMO       - IMO
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 15  

 860          *    CY_LIB_USB_CLK_PLL       - PLL
 861          *    CY_LIB_USB_CLK_DSI       - DSI
 862          *
 863          *******************************************************************************/
 864          void CyUsbClk_SetSource(uint8 source) 
 865          {
 866   1          CY_LIB_CLKDIST_UCFG_REG = (CY_LIB_CLKDIST_UCFG_REG & ((uint8)(~CY_LIB_CLKDIST_UCFG_SRC_SEL_MASK))) |
 867   1                              (CY_LIB_CLKDIST_UCFG_SRC_SEL_MASK & source);
 868   1      }
 869          
 870          
 871          /*******************************************************************************
 872          * Function Name: CyILO_Start1K
 873          ****************************************************************************//**
 874          *
 875          *  Enables the ILO 1 KHz oscillator.
 876          *
 877          *  Note The ILO 1 KHz oscillator is always enabled by default, regardless of the
 878          *  selection in the Clock Editor. Therefore, this API is only needed if the
 879          *  oscillator was turned off manually.
 880          *
 881          *******************************************************************************/
 882          void CyILO_Start1K(void) 
 883          {
 884   1          /* Set bit 1 of ILO RS */
 885   1          CY_LIB_SLOWCLK_ILO_CR0_REG |= CY_LIB_SLOWCLK_ILO_CR0_EN_1KHZ;
 886   1      }
 887          
 888          
 889          /*******************************************************************************
 890          * Function Name: CyILO_Stop1K
 891          ****************************************************************************//**
 892          *
 893          *  Disables the ILO 1 KHz oscillator.
 894          *
 895          *  Note The ILO 1 KHz oscillator must be enabled if the Sleep or Hibernate low
 896          *  power mode APIs are expected to be used. For more information, refer to the
 897          *  Power Management section of this document.
 898          *
 899          * \sideeffect
 900          *  PSoC5: Stopping the ILO 1 kHz could break the active WDT functionality.
 901          *
 902          *******************************************************************************/
 903          void CyILO_Stop1K(void) 
 904          {
 905   1          /* Clear bit 1 of ILO RS */
 906   1          CY_LIB_SLOWCLK_ILO_CR0_REG &= ((uint8)(~CY_LIB_SLOWCLK_ILO_CR0_EN_1KHZ));
 907   1      }
 908          
 909          
 910          /*******************************************************************************
 911          * Function Name: CyILO_Start100K
 912          ****************************************************************************//**
 913          *
 914          *  Enables the ILO 100 KHz oscillator.
 915          *
 916          *******************************************************************************/
 917          void CyILO_Start100K(void) 
 918          {
 919   1          CY_LIB_SLOWCLK_ILO_CR0_REG |= CY_LIB_SLOWCLK_ILO_CR0_EN_100KHZ;
 920   1      }
 921          
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 16  

 922          
 923          /*******************************************************************************
 924          * Function Name: CyILO_Stop100K
 925          ****************************************************************************//**
 926          *
 927          *  Disables the ILO 100 KHz oscillator.
 928          *
 929          *******************************************************************************/
 930          void CyILO_Stop100K(void) 
 931          {
 932   1          CY_LIB_SLOWCLK_ILO_CR0_REG &= ((uint8)(~CY_LIB_SLOWCLK_ILO_CR0_EN_100KHZ));
 933   1      }
 934          
 935          
 936          /*******************************************************************************
 937          * Function Name: CyILO_Enable33K
 938          ****************************************************************************//**
 939          *
 940          *  Enables the ILO 33 KHz divider.
 941          *
 942          *  Note that the 33 KHz clock is generated from the 100 KHz oscillator,
 943          *  so it must also be running in order to generate the 33 KHz output.
 944          *
 945          *******************************************************************************/
 946          void CyILO_Enable33K(void) 
 947          {
 948   1          /* Set bit 5 of ILO RS */
 949   1          CY_LIB_SLOWCLK_ILO_CR0_REG |= CY_LIB_SLOWCLK_ILO_CR0_EN_33KHZ;
 950   1      }
 951          
 952          
 953          /*******************************************************************************
 954          * Function Name: CyILO_Disable33K
 955          ****************************************************************************//**
 956          *
 957          *  Disables the ILO 33 KHz divider.
 958          *
 959          *  Note that the 33 KHz clock is generated from the 100 KHz oscillator, but this
 960          *  API does not disable the 100 KHz clock.
 961          *
 962          *******************************************************************************/
 963          void CyILO_Disable33K(void) 
 964          {
 965   1          CY_LIB_SLOWCLK_ILO_CR0_REG &= ((uint8)(~CY_LIB_SLOWCLK_ILO_CR0_EN_33KHZ));
 966   1      }
 967          
 968          
 969          /*******************************************************************************
 970          * Function Name: CyILO_SetSource
 971          ****************************************************************************//**
 972          *
 973          *  Sets the source of the clock output from the ILO block.
 974          *
 975          *  \param source: One of the three available ILO output sources
 976          *       Value        Define                Source
 977          *       0            CY_ILO_SOURCE_100K    ILO 100 KHz
 978          *       1            CY_ILO_SOURCE_33K     ILO 33 KHz
 979          *       2            CY_ILO_SOURCE_1K      ILO 1 KHz
 980          *
 981          *******************************************************************************/
 982          void CyILO_SetSource(uint8 source) 
 983          {
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 17  

 984   1          CY_LIB_CLKDIST_CR_REG = (CY_LIB_CLKDIST_CR_REG & CY_ILO_SOURCE_BITS_CLEAR) |
 985   1                          (((uint8) (source << 2u)) & ((uint8)(~CY_ILO_SOURCE_BITS_CLEAR)));
 986   1      }
 987          
 988          
 989          /*******************************************************************************
 990          * Function Name: CyILO_SetPowerMode
 991          ****************************************************************************//**
 992          *
 993          * Sets the power mode used by the ILO during power down. Allows for lower power
 994          * down power usage resulting in a slower startup time.
 995          *
 996          * \param mode
 997          * CY_ILO_FAST_START - Faster start-up, internal bias left on when powered down
 998          * CY_ILO_SLOW_START - Slower start-up, internal bias off when powered down
 999          *
1000          * \return Prevous power mode state.
1001          *
1002          *******************************************************************************/
1003          uint8 CyILO_SetPowerMode(uint8 mode) 
1004          {
1005   1          uint8 state;
1006   1      
1007   1          /* Get current state. */
1008   1          state = CY_LIB_SLOWCLK_ILO_CR0_REG;
1009   1      
1010   1          /* Set the oscillator power mode. */
1011   1          if(mode != CY_ILO_FAST_START)
1012   1          {
1013   2              CY_LIB_SLOWCLK_ILO_CR0_REG = (state | CY_ILO_CONTROL_PD_MODE);
1014   2          }
1015   1          else
1016   1          {
1017   2              CY_LIB_SLOWCLK_ILO_CR0_REG = (state & ((uint8)(~CY_ILO_CONTROL_PD_MODE)));
1018   2          }
1019   1      
1020   1          /* Return old mode. */
1021   1          return ((state & CY_ILO_CONTROL_PD_MODE) >> CY_ILO_CONTROL_PD_POSITION);
1022   1      }
1023          
1024          
1025          /*******************************************************************************
1026          * Function Name: CyXTAL_32KHZ_Start
1027          ****************************************************************************//**
1028          *
1029          *  Enables the 32 KHz Crystal Oscillator.
1030          *
1031          *******************************************************************************/
1032          void CyXTAL_32KHZ_Start(void) 
1033          {
1034   1          volatile uint16 i;
1035   1      
1036   1          CY_CLK_XTAL32_TST_REG = CY_CLK_XTAL32_TST_DEFAULT;
1037   1          CY_CLK_XTAL32_TR_REG  = CY_CLK_XTAL32_TR_STARTUP;
1038   1          CY_CLK_XTAL32_CFG_REG = (CY_CLK_XTAL32_CFG_REG & ((uint8)(~CY_CLK_XTAL32_CFG_LP_MASK))) |
1039   1                                      CY_CLK_XTAL32_CFG_LP_DEFAULT;
1040   1      
1041   1          #if(CY_PSOC3)
1042   1              CY_CLK_XTAL32_CR_REG |= CY_CLK_XTAL32_CR_PDBEN;
1043   1          #endif  /* (CY_PSOC3) */
1044   1      
1045   1          /* Enable operation of 32K Crystal Oscillator */
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 18  

1046   1          CY_CLK_XTAL32_CR_REG |= CY_CLK_XTAL32_CR_EN;
1047   1      
1048   1          for (i = 1000u; i > 0u; i--)
1049   1          {
1050   2              if(0u != (CyXTAL_32KHZ_ReadStatus() & CY_XTAL32K_ANA_STAT))
1051   2              {
1052   3                  /* Ready - switch to high power mode */
1053   3                  (void) CyXTAL_32KHZ_SetPowerMode(0u);
1054   3      
1055   3                  break;
1056   3              }
1057   2              CyDelayUs(1u);
1058   2          }
1059   1      }
1060          
1061          
1062          /*******************************************************************************
1063          * Function Name: CyXTAL_32KHZ_Stop
1064          ****************************************************************************//**
1065          *
1066          *  Disables the 32KHz Crystal Oscillator.
1067          *
1068          *******************************************************************************/
1069          void CyXTAL_32KHZ_Stop(void) 
1070          {
1071   1          CY_CLK_XTAL32_TST_REG  = CY_CLK_XTAL32_TST_DEFAULT;
1072   1          CY_CLK_XTAL32_TR_REG   = CY_CLK_XTAL32_TR_POWERDOWN;
1073   1          CY_CLK_XTAL32_CFG_REG = (CY_CLK_XTAL32_CFG_REG & ((uint8)(~CY_CLK_XTAL32_CFG_LP_MASK))) |
1074   1                                   CY_CLK_XTAL32_CFG_LP_DEFAULT;
1075   1          CY_CLK_XTAL32_CR_REG &= ((uint8)(~(CY_CLK_XTAL32_CR_EN | CY_CLK_XTAL32_CR_LPM)));
1076   1      
1077   1          #if(CY_PSOC3)
1078   1              CY_CLK_XTAL32_CR_REG &= ((uint8)(~CY_CLK_XTAL32_CR_PDBEN));
1079   1          #endif  /* (CY_PSOC3) */
1080   1      }
1081          
1082          
1083          /*******************************************************************************
1084          * Function Name: CyXTAL_32KHZ_ReadStatus
1085          ****************************************************************************//**
1086          *
1087          *  Returns status of the 32 KHz oscillator.
1088          *
1089          * \return
1090          *  Value     Define                    Source
1091          *  20        CY_XTAL32K_ANA_STAT       Analog measurement
1092          *                                       1: Stable
1093          *                                       0: Not stable
1094          *
1095          *******************************************************************************/
1096          uint8 CyXTAL_32KHZ_ReadStatus(void) 
1097          {
1098   1          return(CY_CLK_XTAL32_CR_REG & CY_XTAL32K_ANA_STAT);
1099   1      }
1100          
1101          
1102          /*******************************************************************************
1103          * Function Name: CyXTAL_32KHZ_SetPowerMode
1104          ****************************************************************************//**
1105          *
1106          *  Sets the power mode for the 32 KHz oscillator used during the sleep mode.
1107          *  Allows for lower power during sleep when there are fewer sources of noise.
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 19  

1108          *  During the active mode the oscillator is always run in the high power mode.
1109          *
1110          *  uint8 mode
1111          *       \param 0: High power mode
1112          *       \param 1: Low power mode during sleep
1113          *
1114          * \return
1115          *  Previous power mode.
1116          *
1117          *******************************************************************************/
1118          uint8 CyXTAL_32KHZ_SetPowerMode(uint8 mode) 
1119          {
1120   1          uint8 state = (0u != (CY_CLK_XTAL32_CR_REG & CY_CLK_XTAL32_CR_LPM)) ? 1u : 0u;
1121   1      
1122   1          CY_CLK_XTAL32_TST_REG = CY_CLK_XTAL32_TST_DEFAULT;
1123   1      
1124   1          if(1u == mode)
1125   1          {
1126   2              /* Low power mode during Sleep */
1127   2              CY_CLK_XTAL32_TR_REG  = CY_CLK_XTAL32_TR_LOW_POWER;
1128   2              CyDelayUs(10u);
1129   2              CY_CLK_XTAL32_CFG_REG = (CY_CLK_XTAL32_CFG_REG & ((uint8)(~CY_CLK_XTAL32_CFG_LP_MASK))) |
1130   2                                      CY_CLK_XTAL32_CFG_LP_LOWPOWER;
1131   2              CyDelayUs(20u);
1132   2              CY_CLK_XTAL32_CR_REG |= CY_CLK_XTAL32_CR_LPM;
1133   2          }
1134   1          else
1135   1          {
1136   2              /* High power mode */
1137   2              CY_CLK_XTAL32_TR_REG  = CY_CLK_XTAL32_TR_HIGH_POWER;
1138   2              CyDelayUs(10u);
1139   2              CY_CLK_XTAL32_CFG_REG = (CY_CLK_XTAL32_CFG_REG & ((uint8)(~CY_CLK_XTAL32_CFG_LP_MASK))) |
1140   2                                      CY_CLK_XTAL32_CFG_LP_DEFAULT;
1141   2              CY_CLK_XTAL32_CR_REG &= ((uint8)(~CY_CLK_XTAL32_CR_LPM));
1142   2          }
1143   1      
1144   1          return(state);
1145   1      }
1146          
1147          
1148          /*******************************************************************************
1149          * Function Name: CyXTAL_Start
1150          ****************************************************************************//**
1151          *
1152          *  Enables the megahertz crystal.
1153          *
1154          *  PSoC 3:
1155          *  Waits until the XERR bit is low (no error) for a millisecond or until the
1156          *  number of milliseconds specified by the wait parameter has expired.
1157          *
1158          *   \param wait: Valid range [0-255].
1159          *   This is the timeout value in milliseconds.
1160          *   The appropriate value is crystal specific.
1161          *
1162          * \return
1163          *   CYRET_SUCCESS - Completed successfully
1164          *   CYRET_TIMEOUT - Timeout occurred without detecting a low value on XERR.
1165          *
1166          * Side Effects and Restrictions:
1167          *  If wait is enabled (non-zero wait). Uses the Fast Timewheel to time the wait.
1168          *  Any other use of the Fast Timewheel (FTW) will be stopped during the period
1169          *  of this function and then restored.
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 20  

1170          *
1171          *  Uses the 100KHz ILO.  If not enabled, this function will enable the 100KHz
1172          *  ILO for the period of this function. No changes to the setup of the ILO,
1173          *  Fast Timewheel, Central Timewheel or Once Per Second interrupt may be made
1174          *  by interrupt routines during the period of this function.
1175          *
1176          *  The current operation of the ILO, Central Timewheel and Once Per Second
1177          *  interrupt are maintained during the operation of this function provided the
1178          *  reading of the Power Manager Interrupt Status Register is only done using the
1179          *  CyPmReadStatus() function.
1180          *
1181          *******************************************************************************/
1182          cystatus CyXTAL_Start(uint8 wait) 
1183          {
1184   1          cystatus status = CYRET_SUCCESS;
1185   1          volatile uint8  timeout = wait;
1186   1          volatile uint8 count;
1187   1          uint8 iloEnableState;
1188   1          uint8 pmTwCfg0Tmp;
1189   1          uint8 pmTwCfg2Tmp;
1190   1      
1191   1      
1192   1          /* Enables MHz crystal oscillator circuit  */
1193   1          CY_CLK_XMHZ_CSR_REG |= CY_CLK_XMHZ_CSR_ENABLE;
1194   1      
1195   1      
1196   1          if(wait > 0u)
1197   1          {
1198   2              /* Save 100 KHz ILO, FTW interval, enable and interrupt enable */
1199   2              iloEnableState = CY_LIB_SLOWCLK_ILO_CR0_REG;
1200   2              pmTwCfg0Tmp = CY_LIB_PM_TW_CFG0_REG;
1201   2              pmTwCfg2Tmp = CY_LIB_PM_TW_CFG2_REG;
1202   2      
1203   2              /* Set 250 us interval */
1204   2              CyPmFtwSetInterval(CY_CLK_XMHZ_FTW_INTERVAL);
1205   2              status = CYRET_TIMEOUT;
1206   2      
1207   2      
1208   2              for( ; timeout > 0u; timeout--)
1209   2              {
1210   3                  /* Read XERR bit to clear it */
1211   3                  (void) CY_CLK_XMHZ_CSR_REG;
1212   3      
1213   3                  /* Wait for 1 millisecond - 4 x 250 us */
1214   3                  for(count = 4u; count > 0u; count--)
1215   3                  {
1216   4                      while(0u == (CY_PM_FTW_INT & CyPmReadStatus(CY_PM_FTW_INT)))
1217   4                      {
1218   5                          /* Wait for FTW interrupt event */
1219   5                      }
1220   4                  }
1221   3      
1222   3      
1223   3                  /*******************************************************************
1224   3                  * High output indicates an oscillator failure.
1225   3                  * Only can be used after a start-up interval (1 ms) is completed.
1226   3                  *******************************************************************/
1227   3                  if(0u == (CY_CLK_XMHZ_CSR_REG & CY_CLK_XMHZ_CSR_XERR))
1228   3                  {
1229   4                      status = CYRET_SUCCESS;
1230   4                      break;
1231   4                  }
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 21  

1232   3              }
1233   2      
1234   2      
1235   2              /* Restore 100 KHz ILO, FTW interval, enable and interrupt enable */
1236   2              if(0u == (iloEnableState & CY_LIB_SLOWCLK_ILO_CR0_EN_100KHZ))
1237   2              {
1238   3                  CyILO_Stop100K();
1239   3              }
1240   2              CY_LIB_PM_TW_CFG0_REG = pmTwCfg0Tmp;
1241   2              CY_LIB_PM_TW_CFG2_REG = pmTwCfg2Tmp;
1242   2          }
1243   1      
1244   1          return(status);
1245   1      }
1246          
1247          
1248          /*******************************************************************************
1249          * Function Name: CyXTAL_Stop
1250          ****************************************************************************//**
1251          *
1252          *  Disables the megahertz crystal oscillator.
1253          *
1254          *******************************************************************************/
1255          void CyXTAL_Stop(void) 
1256          {
1257   1          /* Disable oscillator. */
1258   1          FASTCLK_XMHZ_CSR &= ((uint8)(~XMHZ_CONTROL_ENABLE));
1259   1      }
1260          
1261          
1262          /*******************************************************************************
1263          * Function Name: CyXTAL_EnableErrStatus
1264          ****************************************************************************//**
1265          *
1266          *  Enables the generation of the XERR status bit for the megahertz crystal.
1267          *  This function is not available for PSoC5.
1268          *
1269          *******************************************************************************/
1270          void CyXTAL_EnableErrStatus(void) 
1271          {
1272   1          /* If oscillator has insufficient amplitude, XERR bit will be high. */
1273   1          CY_CLK_XMHZ_CSR_REG &= ((uint8)(~CY_CLK_XMHZ_CSR_XFB));
1274   1      }
1275          
1276          
1277          /*******************************************************************************
1278          * Function Name: CyXTAL_DisableErrStatus
1279          ****************************************************************************//**
1280          *
1281          *  Disables the generation of the XERR status bit for the megahertz crystal.
1282          *  This function is not available for PSoC5.
1283          *
1284          *******************************************************************************/
1285          void CyXTAL_DisableErrStatus(void) 
1286          {
1287   1          /* If oscillator has insufficient amplitude, XERR bit will be high. */
1288   1          CY_CLK_XMHZ_CSR_REG |= CY_CLK_XMHZ_CSR_XFB;
1289   1      }
1290          
1291          
1292          /*******************************************************************************
1293          * Function Name: CyXTAL_ReadStatus
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 22  

1294          ****************************************************************************//**
1295          *
1296          *  Reads the XERR status bit for the megahertz crystal. This status bit is a
1297          *  sticky, clear on read. This function is not available for PSoC5.
1298          *
1299          * \return
1300          *   Status
1301          *    0: No error
1302          *    1: Error
1303          *
1304          *******************************************************************************/
1305          uint8 CyXTAL_ReadStatus(void) 
1306          {
1307   1          /***************************************************************************
1308   1          * High output indicates an oscillator failure. Only use this after a start-up
1309   1          * interval is completed. This can be used for the status and failure recovery.
1310   1          ***************************************************************************/
1311   1          return((0u != (CY_CLK_XMHZ_CSR_REG & CY_CLK_XMHZ_CSR_XERR)) ? 1u : 0u);
1312   1      }
1313          
1314          
1315          /*******************************************************************************
1316          * Function Name: CyXTAL_EnableFaultRecovery
1317          ****************************************************************************//**
1318          *
1319          *  Enables the fault recovery circuit which will switch to the IMO in the case
1320          *  of a fault in the megahertz crystal circuit. The crystal must be up and
1321          *  running with the XERR bit at 0, before calling this function to prevent
1322          *  an immediate fault switchover. This function is not available for PSoC5.
1323          *
1324          *******************************************************************************/
1325          void CyXTAL_EnableFaultRecovery(void) 
1326          {
1327   1          CY_CLK_XMHZ_CSR_REG |= CY_CLK_XMHZ_CSR_XPROT;
1328   1      }
1329          
1330          
1331          /*******************************************************************************
1332          * Function Name: CyXTAL_DisableFaultRecovery
1333          ****************************************************************************//**
1334          *
1335          *  Disables the fault recovery circuit which will switch to the IMO in the case
1336          *  of a fault in the megahertz crystal circuit. This function is not available
1337          *  for PSoC5.
1338          *
1339          *******************************************************************************/
1340          void CyXTAL_DisableFaultRecovery(void) 
1341          {
1342   1          CY_CLK_XMHZ_CSR_REG &= ((uint8)(~CY_CLK_XMHZ_CSR_XPROT));
1343   1      }
1344          
1345          
1346          /*******************************************************************************
1347          * Function Name: CyXTAL_SetStartup
1348          ****************************************************************************//**
1349          *
1350          *  Sets the startup settings for the crystal. The logic model outputs a
1351          *  frequency (setting + 4) MHz when enabled.
1352          *
1353          *  This is artificial as the actual frequency is determined by an attached
1354          *  external crystal.
1355          *
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 23  

1356          *  \param setting: Valid range [0-31].
1357          *   The value is dependent on the frequency and quality of the crystal being
1358          *   used. Refer to the device TRM and datasheet for more information.
1359          *
1360          *******************************************************************************/
1361          void CyXTAL_SetStartup(uint8 setting) 
1362          {
1363   1          CY_CLK_XMHZ_CFG0_REG = (CY_CLK_XMHZ_CFG0_REG & ((uint8)(~CY_CLK_XMHZ_CFG0_XCFG_MASK))) |
1364   1                                 (setting & CY_CLK_XMHZ_CFG0_XCFG_MASK);
1365   1      }
1366          
1367          
1368          
1369          /*******************************************************************************
1370          * Function Name: CyXTAL_SetFbVoltage
1371          ****************************************************************************//**
1372          *
1373          *  Sets the feedback reference voltage to use for the crystal circuit.
1374          *  This function is only available for PSoC3 and PSoC 5LP.
1375          *
1376          *  \param setting: Valid range [0-15].
1377          *  Refer to the device TRM and datasheet for more information.
1378          *
1379          *******************************************************************************/
1380          void CyXTAL_SetFbVoltage(uint8 setting) 
1381          {
1382   1          CY_CLK_XMHZ_CFG1_REG = ((CY_CLK_XMHZ_CFG1_REG & ((uint8)(~CY_CLK_XMHZ_CFG1_VREF_FB_MASK))) |
1383   1                                  (setting & CY_CLK_XMHZ_CFG1_VREF_FB_MASK));
1384   1      }
1385          
1386          
1387          /*******************************************************************************
1388          * Function Name: CyXTAL_SetWdVoltage
1389          ****************************************************************************//**
1390          *
1391          *  Sets the reference voltage used by the watchdog to detect a failure in the
1392          *  crystal circuit. This function is only available for PSoC3 and PSoC 5LP.
1393          *
1394          *  \param setting: Valid range [0-7].
1395          *  Refer to the device TRM and datasheet for more information.
1396          *
1397          *******************************************************************************/
1398          void CyXTAL_SetWdVoltage(uint8 setting) 
1399          {
1400   1          CY_CLK_XMHZ_CFG1_REG = ((CY_CLK_XMHZ_CFG1_REG & ((uint8)(~CY_CLK_XMHZ_CFG1_VREF_WD_MASK))) |
1401   1                                  (((uint8)(setting << 4u)) & CY_CLK_XMHZ_CFG1_VREF_WD_MASK));
1402   1      }
1403          
1404          
1405          /*******************************************************************************
1406          * Function Name: CyHalt
1407          ****************************************************************************//**
1408          *
1409          *  Halts the CPU.
1410          *
1411          *  \param uint8 reason: Value to be used during debugging.
1412          *
1413          *******************************************************************************/
1414          void CyHalt(uint8 reason) CYREENTRANT
1415          {
1416   1          if(0u != reason)
1417   1          {
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 24  

1418   2              /* To remove unreferenced local variable warning */
1419   2          }
1420   1      
1421   1          #if defined (__ARMCC_VERSION)
                      __breakpoint(0x0);
                  #elif defined(__GNUC__) || defined (__ICCARM__)
                      __asm("    bkpt    1");
                  #elif defined(__C51__)
1426   1              CYDEV_HALT_CPU;
1427   1          #endif  /* (__ARMCC_VERSION) */
1428   1      }
1429          
1430          
1431          /*******************************************************************************
1432          * Function Name: CySoftwareReset
1433          ****************************************************************************//**
1434          *
1435          *  Forces a device software reset.
1436          *
1437          *******************************************************************************/
1438          void CySoftwareReset(void) 
1439          {
1440   1          CY_LIB_RESET_CR2_REG |= CY_LIB_RESET_CR2_RESET;
1441   1      }
1442          
1443          
1444          /*******************************************************************************
1445          * Function Name: CyDelay
1446          ****************************************************************************//**
1447          *
1448          *  Blocks for milliseconds.
1449          *
1450          *  Note:
1451          *  CyDelay has been implemented with the instruction cache assumed enabled. When
1452          *  the instruction cache is disabled on PSoC5, CyDelay will be two times larger.
1453          *  For example, with instruction cache disabled CyDelay(100) would result in
1454          *  about 200 ms delay instead of 100 ms.
1455          *
1456          *  \param milliseconds: number of milliseconds to delay.
1457          *
1458          *******************************************************************************/
1459          void CyDelay(uint32 milliseconds) CYREENTRANT
1460          {
1461   1          while (milliseconds > 32768u)
1462   1          {
1463   2              /***********************************************************************
1464   2              * This loop prevents overflow.At 100MHz, milliseconds * delay_freq_khz
1465   2              * overflows at about 42 seconds.
1466   2              ***********************************************************************/
1467   2              CyDelayCycles(cydelay_32k_ms);
1468   2              milliseconds = ((uint32)(milliseconds - 32768u));
1469   2          }
1470   1      
1471   1          CyDelayCycles(milliseconds * cydelay_freq_khz);
1472   1      }
1473          
1474          
1475          #if(!CY_PSOC3)
              
                  /* For PSoC3 devices function is defined in CyBootAsmKeil.a51 file */
              
                  /*******************************************************************************
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 25  

                  * Function Name: CyDelayUs
                  ****************************************************************************//**
                  *
                  *  Blocks for microseconds.
                  *
                  *  Note:
                  *   CyDelay has been implemented with the instruction cache assumed enabled.
                  *   When instruction cache is disabled on PSoC5, CyDelayUs will be two times
                  *   larger. Ex: With instruction cache disabled CyDelayUs(100) would result
                  *   in about 200us delay instead of 100us.
                  *
                  *  \param uint16 microseconds: number of microseconds to delay.
                  *
                  * \sideeffect
                  *  CyDelayUS has been implemented with the instruction cache assumed enabled.
                  *  When the instruction cache is disabled on PSoC 5, CyDelayUs will be two times
                  *  larger. For example, with the instruction cache disabled CyDelayUs(100) would
                  *  result in about 200 us delay instead of 100 us.
                  *
                  *  If the bus clock frequency is a small non-integer number, the actual delay
                  *  can be up to twice as long as the nominal value. The actual delay cannot be
                  *  shorter than the nominal one.
                  *******************************************************************************/
                  void CyDelayUs(uint16 microseconds) CYREENTRANT
                  {
                      CyDelayCycles((uint32)microseconds * cydelay_freq_mhz);
                  }
              
              #endif  /* (!CY_PSOC3) */
1509          
1510          
1511          /*******************************************************************************
1512          * Function Name: CyDelayFreq
1513          ****************************************************************************//**
1514          *
1515          *  Sets the clock frequency for CyDelay.
1516          *
1517          *  \param freq: The frequency of the bus clock in Hertz.
1518          *
1519          *******************************************************************************/
1520          void CyDelayFreq(uint32 freq) CYREENTRANT
1521          {
1522   1          if (freq != 0u)
1523   1          {
1524   2              cydelay_freq_hz = freq;
1525   2          }
1526   1          else
1527   1          {
1528   2              cydelay_freq_hz = BCLK__BUS_CLK__HZ;
1529   2          }
1530   1      
1531   1          cydelay_freq_mhz = (uint8)((cydelay_freq_hz + 999999u) / 1000000u);
1532   1          cydelay_freq_khz = (cydelay_freq_hz + 999u) / 1000u;
1533   1          cydelay_32k_ms   = 32768u * cydelay_freq_khz;
1534   1      }
1535          
1536          
1537          /*******************************************************************************
1538          * Function Name: CyWdtStart
1539          ****************************************************************************//**
1540          *
1541          *  Enables the watchdog timer.
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 26  

1542          *
1543          *  The timer is configured for the specified count interval, the central
1544          *  timewheel is cleared, the setting for the low power mode is configured and
1545          *  the watchdog timer is enabled.
1546          *
1547          *  Once enabled the watchdog cannot be disabled. The watchdog counts each time
1548          *  the Central Time Wheel (CTW) reaches the period specified. The watchdog must
1549          *  be cleared using the CyWdtClear() function before three ticks of the watchdog
1550          *  timer occur. The CTW is free running, so this will occur after between 2 and
1551          *  3 timer periods elapse.
1552          *
1553          *  PSoC5: The watchdog timer should not be used during sleep modes. Since the
1554          *  WDT cannot be disabled after it is enabled, the WDT timeout period can be
1555          *  set to be greater than the sleep wakeup period, then feed the dog on each
1556          *  wakeup from Sleep.
1557          *
1558          *  \param ticks: One of the four available timer periods. Once WDT enabled, the
1559             interval cannot be changed.
1560          *         CYWDT_2_TICKS     -     4 - 6     ms
1561          *         CYWDT_16_TICKS    -    32 - 48    ms
1562          *         CYWDT_128_TICKS   -   256 - 384   ms
1563          *         CYWDT_1024_TICKS  - 2.048 - 3.072 s
1564          *
1565          *  \param lpMode: Low power mode configuration. This parameter is ignored for PSoC 5.
1566          *          The WDT always acts as if CYWDT_LPMODE_NOCHANGE is passed.
1567          *
1568          *          CYWDT_LPMODE_NOCHANGE - No Change
1569          *          CYWDT_LPMODE_MAXINTER - Switch to longest timer mode during low power
1570          *                                 mode
1571          *          CYWDT_LPMODE_DISABLED - Disable WDT during low power mode
1572          *
1573          * \sideeffect
1574          *  PSoC5: The ILO 1 KHz must be enabled for proper WDT operation. Stopping the
1575          *  ILO 1 kHz could break the active WDT functionality.
1576          *
1577          *******************************************************************************/
1578          void CyWdtStart(uint8 ticks, uint8 lpMode) 
1579          {
1580   1          /* Set WDT interval */
1581   1          CY_WDT_CFG_REG = (CY_WDT_CFG_REG & ((uint8)(~CY_WDT_CFG_INTERVAL_MASK))) | (ticks & CY_WDT_CFG_INTERVA
             -L_MASK);
1582   1      
1583   1          /* Reset CTW to ensure that first watchdog period is full */
1584   1          CY_WDT_CFG_REG |= CY_WDT_CFG_CTW_RESET;
1585   1          CY_WDT_CFG_REG &= ((uint8)(~CY_WDT_CFG_CTW_RESET));
1586   1      
1587   1          /* Setting low power mode */
1588   1          CY_WDT_CFG_REG = (((uint8)(lpMode << CY_WDT_CFG_LPMODE_SHIFT)) & CY_WDT_CFG_LPMODE_MASK) |
1589   1                             (CY_WDT_CFG_REG & ((uint8)(~CY_WDT_CFG_LPMODE_MASK)));
1590   1      
1591   1          /* Enables watchdog reset */
1592   1          CY_WDT_CFG_REG |= CY_WDT_CFG_WDR_EN;
1593   1      }
1594          
1595          
1596          /*******************************************************************************
1597          * Function Name: CyWdtClear
1598          ****************************************************************************//**
1599          *
1600          *  Clears (feeds) the watchdog timer.
1601          *
1602          *******************************************************************************/
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 27  

1603          void CyWdtClear(void) 
1604          {
1605   1          CY_WDT_CR_REG = CY_WDT_CR_FEED;
1606   1      }
1607          
1608          
1609          
1610          /*******************************************************************************
1611          * Function Name: CyVdLvDigitEnable
1612          ****************************************************************************//**
1613          *
1614          *  Sets the voltage trip level, enables the output of the digital low-voltage
1615          *  monitor, and optionally configures voltage monitor to reset device upon the
1616          *  low-voltage event instead of generating an interrupt.
1617          *
1618          *  Note The associated interrupt enable/disable state is not changed by the
1619          *  function. The Interrupt component API should be used to register the
1620          *  interrupt service routine and to enable/disable associated interrupt.
1621          *
1622          *  \param reset: Enables device reset on digital low-voltage event:
1623          *   Zero - Interrupt on digital low-voltage event
1624          *   Non-zero - Reset on digital low-voltage event
1625          *
1626          *  \param threshold: Sets the trip point of the digital low-voltage monitoring circuit
1627          *   in steps of approximately 250 mV in range from 1.70 V (0x00) to 5.45 V
1628          *   (0x0F). For example, the trip point is set to 1.80 V when the threshold
1629          *   parameter value is 0x04. Refer to the device TRM for the exact trip voltage
1630          *   values.
1631          *
1632          * Side Effects and Restrictions:
1633          *  The voltage resets are momentary. When a voltage reset (analog/digital
1634          *  low-voltage and analog high-voltage) occurs, the RESET_CR1 and RESET_CR3
1635          *  registers are restored to their default values. This means that the voltage
1636          *  monitor circuit is no longer enabled and the device exits reset. If the
1637          *  supply is below the trip level and firmware enables the voltage reset
1638          *  functionality, the device will reset again. This will continue as long as the
1639          *  supply is below the trip level or as long as the user enables the reset
1640          *  functionality of the voltage monitor functionality.
1641          *
1642          *  When any voltage reset occurs, the RESET_SR0 and RESET_SR2 status registers
1643          *  are cleared. This means that analog low-voltage, digital low-voltage and
1644          *  analog high-voltage status bits are not persistent across any voltage reset.
1645          *
1646          *******************************************************************************/
1647          void CyVdLvDigitEnable(uint8 reset, uint8 threshold) 
1648          {
1649   1          uint32 intRegTmp;
1650   1          uint8 interruptState;
1651   1      
1652   1          interruptState = CyEnterCriticalSection();
1653   1      
1654   1          /* Store interrupt enable state */
1655   1          intRegTmp = CY_INT_ENABLE_REG & CY_VD_INT_MASK;
1656   1      
1657   1          /* Disable VD interrupt (write 1) to protect against glitches */
1658   1          CY_INT_CLEAR_REG = CY_VD_INT_MASK;
1659   1      
1660   1          CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESD_EN));
1661   1      
1662   1          CY_VD_LVI_TRIP_REG = (threshold & CY_VD_LVI_TRIP_LVID_MASK) |
1663   1                                  (CY_VD_LVI_TRIP_REG & ((uint8)(~CY_VD_LVI_TRIP_LVID_MASK)));
1664   1          CY_VD_LVI_HVI_CONTROL_REG |= CY_VD_LVID_EN;
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 28  

1665   1      
1666   1          /* Timeout to eliminate glitches on LVI/HVI when enabling (ID # 127412) */
1667   1          CyDelayUs(1u);
1668   1      
1669   1          (void) CyVdStickyStatus(CY_VD_LVID);
1670   1      
1671   1          if(0u != reset)
1672   1          {
1673   2              CY_VD_PRES_CONTROL_REG |= CY_VD_PRESD_EN;
1674   2          }
1675   1          else
1676   1          {
1677   2              CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESD_EN));
1678   2          }
1679   1      
1680   1          /* Clear pending interrupt */
1681   1          CY_INT_CLR_PEND_REG = CY_VD_INT_MASK;
1682   1      
1683   1          /* Restore interrupt enable state */
1684   1          CY_INT_ENABLE_REG = intRegTmp;
1685   1      
1686   1          CyExitCriticalSection(interruptState);
1687   1      }
1688          
1689          
1690          /*******************************************************************************
1691          * Function Name: CyVdLvAnalogEnable
1692          ****************************************************************************//**
1693          *
1694          *  Sets the voltage trip level, enables the output of the analog low-voltage
1695          *  monitor, and optionally configures voltage monitor to reset device upon the
1696          *  low-voltage event instead of generating an interrupt.
1697          *
1698          *  Note The associated interrupt enable/disable state is not changed by the
1699          *  function. The Interrupt component API should be used to register the
1700          *  interrupt service routine and to enable/disable associated interrupt.
1701          *
1702          *  \param reset: Enables device reset on analog low-voltage event:
1703          *  Zero - Interrupt on analog low-voltage event
1704          *  Non-zero - Reset on analog low-voltage event
1705          *
1706          *  \param threshold: Sets the trip point of the analog low-voltage monitoring circuit
1707          *  in steps of approximately 250 mV in range from 1.70 V (0x00) to 5.45 V
1708          *  (0x0F). For example, the trip point is set to 1.80 V when value of the
1709          *  threshold parameter is 0x04. Please refer to the device TRM for the exact
1710          *  trip voltage values.
1711          *
1712          * Side Effects and Restrictions:
1713          *  The voltage resets are momentary. When a voltage reset (analog/digital
1714          *  low-voltage and analog high-voltage) occurs, the RESET_CR1 and RESET_CR3
1715          *  registers are restored to their default values. This means that the voltage
1716          *  monitor circuit is no longer enabled and the device exits reset. If the
1717          *  supply is below the trip level and firmware enables the voltage reset
1718          *  functionality, the device will reset again. This will continue as long as
1719          *  the supply is below the trip level or as long as the user enables the reset
1720          *  functionality of the voltage monitor functionality.
1721          *
1722          *  When any voltage reset occurs, the RESET_SR0 and RESET_SR2 status registers
1723          *  are cleared. This means that analog low-voltage, digital low-voltage and
1724          *  analog high-voltage status bits are not persistent across any voltage reset.
1725          *
1726          *******************************************************************************/
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 29  

1727          void CyVdLvAnalogEnable(uint8 reset, uint8 threshold) 
1728          {
1729   1          uint32 intRegTmp;
1730   1          uint8 interruptState;
1731   1      
1732   1          interruptState = CyEnterCriticalSection();
1733   1      
1734   1          /* Store interrupt enable state */
1735   1          intRegTmp = CY_INT_ENABLE_REG & CY_VD_INT_MASK;
1736   1      
1737   1          /* Disable VD interrupt (write 1) to protect against glitches */
1738   1          CY_INT_CLEAR_REG = CY_VD_INT_MASK;
1739   1      
1740   1          CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESA_EN));
1741   1      
1742   1          CY_VD_LVI_TRIP_REG = ((uint8)(threshold << 4u)) | (CY_VD_LVI_TRIP_REG & 0x0Fu);
1743   1          CY_VD_LVI_HVI_CONTROL_REG |= CY_VD_LVIA_EN;
1744   1      
1745   1          /* Timeout to eliminate glitches on LVI/HVI when enabling (ID # 127412) */
1746   1          CyDelayUs(1u);
1747   1      
1748   1          (void) CyVdStickyStatus(CY_VD_LVIA);
1749   1      
1750   1          if(0u != reset)
1751   1          {
1752   2              CY_VD_PRES_CONTROL_REG |= CY_VD_PRESA_EN;
1753   2          }
1754   1          else
1755   1          {
1756   2              CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESA_EN));
1757   2          }
1758   1      
1759   1          /* Clear pending interrupt */
1760   1          CY_INT_CLR_PEND_REG = CY_VD_INT_MASK;
1761   1      
1762   1          /* Restore interrupt enable state */
1763   1          CY_INT_ENABLE_REG = intRegTmp;
1764   1      
1765   1          CyExitCriticalSection(interruptState);
1766   1      }
1767          
1768          
1769          /*******************************************************************************
1770          * Function Name: CyVdLvDigitDisable
1771          ****************************************************************************//**
1772          *
1773          *  Disables the digital low-voltage monitor, turns off device reset upon the
1774          *  digital low-voltage event, and clears the associated persistent status bit.
1775          *
1776          *  Note The associated interrupt enable/disable state is not changed by the
1777          *  function. The pending interrupt status is not cleared. The Interrupt
1778          *  component API should be used to manipulate with the associated interrupts.
1779          *
1780          *******************************************************************************/
1781          void CyVdLvDigitDisable(void) 
1782          {
1783   1          CY_VD_LVI_HVI_CONTROL_REG &= ((uint8)(~CY_VD_LVID_EN));
1784   1          CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESD_EN));
1785   1          (void) CyVdStickyStatus(CY_VD_LVID);
1786   1      
1787   1          while(0u != (CyVdStickyStatus(CY_VD_LVID) & CY_VD_LVID))
1788   1          {
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 30  

1789   2      
1790   2          }
1791   1      }
1792          
1793          
1794          /*******************************************************************************
1795          * Function Name: CyVdLvAnalogDisable
1796          ****************************************************************************//**
1797          *
1798          *  Disables the analog low-voltage monitor, turns off device reset upon the
1799          *  analog low-voltage event, and clears the associated persistent status bit.
1800          *
1801          *  Note The associated interrupt enable/disable state is not changed by the
1802          *  function. The pending interrupt status is not cleared. The Interrupt
1803          *  component API should be used to manipulate with the associated interrupts.
1804          *
1805          *******************************************************************************/
1806          void CyVdLvAnalogDisable(void) 
1807          {
1808   1          CY_VD_LVI_HVI_CONTROL_REG &= ((uint8)(~CY_VD_LVIA_EN));
1809   1          CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESA_EN));
1810   1          while(0u != (CyVdStickyStatus(CY_VD_LVIA) & CY_VD_LVIA))
1811   1          {
1812   2      
1813   2          }
1814   1      }
1815          
1816          
1817          /*******************************************************************************
1818          * Function Name: CyVdHvAnalogEnable
1819          ****************************************************************************//**
1820          *
1821          *  Enables the output of the analog high-voltage monitor and sets 5.75 V
1822          *  threshold detection for Vdda.
1823          *
1824          *  Note The associated interrupt enable/disable state is not changed by the
1825          *  function. The Interrupt component API should be used to register the
1826          *  interrupt service routine and to enable/disable associated interrupt.
1827          *
1828          *******************************************************************************/
1829          void CyVdHvAnalogEnable(void) 
1830          {
1831   1          uint32 intRegTmp;
1832   1          uint8 interruptState;
1833   1      
1834   1          interruptState = CyEnterCriticalSection();
1835   1      
1836   1          /* Store interrupt enable state */
1837   1          intRegTmp = CY_INT_ENABLE_REG & CY_VD_INT_MASK;
1838   1      
1839   1          /* Disable VD interrupt (write 1) to protect against glitches */
1840   1          CY_INT_CLEAR_REG = CY_VD_INT_MASK;
1841   1      
1842   1          CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESA_EN));
1843   1      
1844   1          CY_VD_LVI_HVI_CONTROL_REG |= CY_VD_HVIA_EN;
1845   1      
1846   1          /* Timeout to eliminate glitches on the LVI/HVI when enabling (ID # 127412)  */
1847   1          CyDelayUs(1u);
1848   1      
1849   1          (void) CyVdStickyStatus(CY_VD_HVIA);
1850   1      
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 31  

1851   1          /* Clear pending interrupt */
1852   1          CY_INT_CLR_PEND_REG = CY_VD_INT_MASK;
1853   1      
1854   1          /* Restore interrupt enable state */
1855   1          CY_INT_ENABLE_REG = intRegTmp;
1856   1      
1857   1          CyExitCriticalSection(interruptState);
1858   1      }
1859          
1860          
1861          /*******************************************************************************
1862          * Function Name: CyVdHvAnalogDisable
1863          ****************************************************************************//**
1864          *
1865          *  Disables the analog high-voltage monitor and clears the associated persistent
1866          *  status bit.
1867          *
1868          *  Note The associated interrupt enable/disable state is not changed by the
1869          *  function. The pending interrupt status is not cleared. The Interrupt
1870          *  component API should be used to manipulate with the associated interrupts.
1871          *
1872          *******************************************************************************/
1873          void CyVdHvAnalogDisable(void) 
1874          {
1875   1          CY_VD_LVI_HVI_CONTROL_REG &= ((uint8)(~CY_VD_HVIA_EN));
1876   1          while(0u != (CyVdStickyStatus(CY_VD_HVIA) & CY_VD_HVIA))
1877   1          {
1878   2      
1879   2          }
1880   1      }
1881          
1882          
1883          /*******************************************************************************
1884          * Function Name: CyVdStickyStatus
1885          ****************************************************************************//**
1886          *
1887          *  Reads and clears the voltage detection status bits in the RESET_SR0 register.
1888          *  The bits are set to 1 by the voltage monitor circuit when the supply is
1889          *  outside the detector trip point. They stay set to 1 until they are read or
1890          *  a POR / LVI / PRES reset occurs. This function uses a shadow register, so
1891          *  only the bits passed in the parameter will be cleared in the shadow register.
1892          *
1893          *  \param mask: Bits in the RESET_SR0 shadow register to clear and return.
1894          *   Define                  Definition
1895          *   CY_VD_LVID            Persistent status of digital LVI.
1896          *   CY_VD_LVIA            Persistent status of analog LVI.
1897          *   CY_VD_HVIA            Persistent status of analog HVI.
1898          *
1899          * \return
1900          *  Status. Same enumerated bit values as used for the mask parameter. A zero is
1901          *  returned for bits not used in the mask parameter.
1902          *
1903          * Side Effects and Restrictions:
1904          *  When an LVI reset occurs, the RESET_SR0 status registers are cleared. This
1905          *  means that the voltage detection status bits are not persistent across an LVI
1906          *  reset and cannot be used to determine a reset source.
1907          *
1908          *******************************************************************************/
1909          uint8 CyVdStickyStatus(uint8 mask) 
1910          {
1911   1          static uint8 interruptStatus;
1912   1          uint8 interruptState;
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 32  

1913   1          uint8 tmpStatus;
1914   1      
1915   1          interruptState = CyEnterCriticalSection();
1916   1      
1917   1          interruptStatus |= CY_VD_PERSISTENT_STATUS_REG;
1918   1          tmpStatus = interruptStatus & (uint8)(CY_VD_LVID | CY_VD_LVIA | CY_VD_HVIA);
1919   1          interruptStatus &= ((uint8)(~mask));
1920   1      
1921   1          CyExitCriticalSection(interruptState);
1922   1      
1923   1          return(tmpStatus);
1924   1      }
1925          
1926          
1927          /*******************************************************************************
1928          * Function Name: CyVdRealTimeStatus
1929          ****************************************************************************//**
1930          *
1931          *  Reads the real-time voltage detection status bits in the RESET_SR2 register.
1932          *  The bits are set to 1 by the voltage monitor circuit when the supply is
1933          *  outside the detector’s trip point, and set to 0 when the supply is inside the
1934          *  trip point.
1935          *
1936          * \return
1937          *  Status of the LVID, LVIA, and HVIA bits in the RESET_SR2 register.
1938          *   Define                  Definition
1939          *   CY_VD_LVID            Real-time status of digital LVI.
1940          *   CY_VD_LVIA            Real-time status of analog LVI.
1941          *   CY_VD_HVIA            Real-time status of analog HVI.
1942          *
1943          * Side Effects and Restrictions:
1944          *  When an LVI reset occurs, the RESET_SR2 status registers are cleared. This
1945          *  means that the voltage detection status bits are not persistent across an LVI
1946          *  reset and cannot be used to determine a reset source.
1947          *
1948          *******************************************************************************/
1949          uint8 CyVdRealTimeStatus(void) 
1950          {
1951   1          uint8 interruptState;
1952   1          uint8 vdFlagsState;
1953   1      
1954   1          interruptState = CyEnterCriticalSection();
1955   1          vdFlagsState = CY_VD_RT_STATUS_REG & (CY_VD_LVID | CY_VD_LVIA | CY_VD_HVIA);
1956   1          CyExitCriticalSection(interruptState);
1957   1      
1958   1          return(vdFlagsState);
1959   1      }
1960          
1961          
1962          /*******************************************************************************
1963          * Function Name: CyDisableInts
1964          ****************************************************************************//**
1965          *
1966          *  Disables the interrupt enable for each interrupt.
1967          *
1968          * \return
1969          *  32 bit mask of previously enabled interrupts.
1970          *
1971          *******************************************************************************/
1972          uint32 CyDisableInts(void) 
1973          {
1974   1          uint32 intState;
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 33  

1975   1          uint8 interruptState;
1976   1      
1977   1          interruptState = CyEnterCriticalSection();
1978   1      
1979   1          #if(CY_PSOC3)
1980   1      
1981   1              /* Get the current interrupt state. */
1982   1              intState  = ((uint32) CY_GET_REG8(CY_INT_CLR_EN0_PTR));
1983   1              intState |= ((uint32) (((uint32) CY_GET_REG8(CY_INT_CLR_EN1_PTR)) << 8u));
1984   1              intState |= ((uint32) (((uint32) CY_GET_REG8(CY_INT_CLR_EN2_PTR)) << 16u));
1985   1              intState |= ((uint32) (((uint32) CY_GET_REG8(CY_INT_CLR_EN3_PTR)) << 24u));
1986   1      
1987   1      
1988   1              /* Disable all of the interrupts. */
1989   1              CY_SET_REG8(CY_INT_CLR_EN0_PTR, 0xFFu);
1990   1              CY_SET_REG8(CY_INT_CLR_EN1_PTR, 0xFFu);
1991   1              CY_SET_REG8(CY_INT_CLR_EN2_PTR, 0xFFu);
1992   1              CY_SET_REG8(CY_INT_CLR_EN3_PTR, 0xFFu);
1993   1      
1994   1          #else
              
                      /* Get the current interrupt state. */
                      intState = CY_GET_REG32(CY_INT_CLEAR_PTR);
              
                      /* Disable all of the interrupts. */
                      CY_SET_REG32(CY_INT_CLEAR_PTR, 0xFFFFFFFFu);
              
                  #endif /* (CY_PSOC3) */
2003   1      
2004   1          CyExitCriticalSection(interruptState);
2005   1      
2006   1          return (intState);
2007   1      }
2008          
2009          
2010          /*******************************************************************************
2011          * Function Name: CyEnableInts
2012          ****************************************************************************//**
2013          *
2014          *  Enables interrupts to a given state.
2015          *
2016          *  \param uint32 mask: 32 bit mask of interrupts to enable.
2017          *
2018          *******************************************************************************/
2019          void CyEnableInts(uint32 mask) 
2020          {
2021   1      
2022   1          uint8 interruptState;
2023   1      
2024   1          interruptState = CyEnterCriticalSection();
2025   1      
2026   1          #if(CY_PSOC3)
2027   1      
2028   1              /* Set interrupts as enabled. */
2029   1              CY_SET_REG8(CY_INT_SET_EN3_PTR, ((uint8) (mask >> 24u)));
2030   1              CY_SET_REG8(CY_INT_SET_EN2_PTR, ((uint8) (mask >> 16u)));
2031   1              CY_SET_REG8(CY_INT_SET_EN1_PTR, ((uint8) (mask >> 8u )));
2032   1              CY_SET_REG8(CY_INT_SET_EN0_PTR, ((uint8) (mask )));
2033   1      
2034   1          #else
              
                      CY_SET_REG32(CY_INT_ENABLE_PTR, mask);
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 34  

              
                  #endif /* (CY_PSOC3) */
2039   1      
2040   1          CyExitCriticalSection(interruptState);
2041   1      
2042   1      }
2043          
2044          #if(CY_PSOC5)
              
                  /*******************************************************************************
                  * Function Name: CyFlushCache
                  ****************************************************************************//**
                  *  Call this API after a flash row erase/write operation to invalidate or flush
                  *  any of that particular flash region content already present in the cache.
                  *  After a cache flush operation, any access to that flash region after the
                  *  erase/write operation would reload the cache with the modified data from the
                  *  flash region. If the flash region update involves multiple flash row write
                  *  operations, then the flushing of the cache can be done once at the end of
                  *  the operation as long as the flash data would not be accessed in the middle
                  *  of the multiple row update process. Else, flush the cache after every flash
                  *  row write.
                  *
                  *******************************************************************************/
                  void CyFlushCache(void)
                  {
                      uint8 interruptState;
              
                      /* Save current global interrupt enable and disable it */
                      interruptState = CyEnterCriticalSection();
              
                      /* Fill instruction prefectch unit to insure data integrity */
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
              
                      /* All entries in cache are invalidated on next clock cycle. */
                      CY_CACHE_CONTROL_REG |= CY_CACHE_CONTROL_FLUSH;
              
                      /* Once this is executed it's guaranteed the cache has been flushed */
                      (void) CY_CACHE_CONTROL_REG;
              
                      /* Flush the pipeline */
                      CY_SYS_ISB;
              
                      /* Restore global interrupt enable state */
                      CyExitCriticalSection(interruptState);
                  }
              
              
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 35  

                  /*******************************************************************************
                  * Function Name: CyIntSetSysVector
                  ****************************************************************************//**
                  *  Sets the interrupt vector of the specified system interrupt number. System
                  *  interrupts are present only for the ARM platform. These interrupts are for
                  *  SysTick, PendSV and others.
                  *
                  *  \param number: System interrupt number:
                  *    CY_INT_NMI_IRQN                - Non Maskable Interrupt
                  *    CY_INT_HARD_FAULT_IRQN         - Hard Fault Interrupt
                  *    CY_INT_MEM_MANAGE_IRQN         - Memory Management Interrupt
                  *    CY_INT_BUS_FAULT_IRQN          - Bus Fault Interrupt
                  *    CY_INT_USAGE_FAULT_IRQN        - Usage Fault Interrupt
                  *    CY_INT_SVCALL_IRQN             - SV Call Interrupt
                  *    CY_INT_DEBUG_MONITOR_IRQN      - Debug Monitor Interrupt
                  *    CY_INT_PEND_SV_IRQN            - Pend SV Interrupt
                  *    CY_INT_SYSTICK_IRQN            - System Tick Interrupt
                  *
                  *  \param address: Pointer to an interrupt service routine.
                  *
                  * \return
                  *   The old ISR vector at this location.
                  *
                  *******************************************************************************/
                  cyisraddress CyIntSetSysVector(uint8 number, cyisraddress address)
                  {
                      cyisraddress oldIsr;
                      cyisraddress *ramVectorTable = *CY_INT_VECT_TABLE;
              
                      CYASSERT(number <= CY_INT_SYS_NUMBER_MAX);
              
                      /* Save old Interrupt service routine. */
                      oldIsr = ramVectorTable[number & CY_INT_SYS_NUMBER_MASK];
              
                      /* Set new Interrupt service routine. */
                      ramVectorTable[number & CY_INT_SYS_NUMBER_MASK] = address;
              
                      return (oldIsr);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntGetSysVector
                  ****************************************************************************//**
                  *
                  *  Gets the interrupt vector of the specified system interrupt number. System
                  *  interrupts are present only for the ARM platform. These interrupts are for
                  *  SysTick, PendSV and others.
                  *
                  *  \param number: System interrupt number:
                  *    CY_INT_NMI_IRQN                - Non Maskable Interrupt
                  *    CY_INT_HARD_FAULT_IRQN         - Hard Fault Interrupt
                  *    CY_INT_MEMORY_MANAGEMENT_IRQN  - Memory Management Interrupt
                  *    CY_INT_BUS_FAULT_IRQN          - Bus Fault Interrupt
                  *    CY_INT_USAGE_FAULT_IRQN        - Usage Fault Interrupt
                  *    CY_INT_SVCALL_IRQN             - SV Call Interrupt
                  *    CY_INT_DEBUG_MONITOR_IRQN      - Debug Monitor Interrupt
                  *    CY_INT_PEND_SV_IRQN            - Pend SV Interrupt
                  *    CY_INT_SYSTICK_IRQN            - System Tick Interrupt
                  *
                  * \return
                  *   Address of the ISR in the interrupt vector table.
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 36  

                  *
                  *******************************************************************************/
                  cyisraddress CyIntGetSysVector(uint8 number)
                  {
                      cyisraddress *ramVectorTable = *CY_INT_VECT_TABLE;
                      CYASSERT(number <= CY_INT_SYS_NUMBER_MAX);
              
                      return ramVectorTable[number & CY_INT_SYS_NUMBER_MASK];
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntSetVector
                  ****************************************************************************//**
                  *
                  *  Sets the interrupt vector of the specified interrupt number.
                  *
                  *  \param number: Valid range [0-31].  Interrupt number
                  *  \param address: Pointer to an interrupt service routine
                  *
                  * \return
                  *   Previous interrupt vector value.
                  *
                  *******************************************************************************/
                  cyisraddress CyIntSetVector(uint8 number, cyisraddress address)
                  {
                      cyisraddress oldIsr;
                      cyisraddress *ramVectorTable = *CY_INT_VECT_TABLE;
              
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
              
                      /* Save old Interrupt service routine. */
                      oldIsr = ramVectorTable[CY_INT_IRQ_BASE + (number & CY_INT_NUMBER_MASK)];
              
                      /* Set new Interrupt service routine. */
                      ramVectorTable[CY_INT_IRQ_BASE + (number & CY_INT_NUMBER_MASK)] = address;
              
                      return (oldIsr);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntGetVector
                  ****************************************************************************//**
                  *
                  *  Gets the interrupt vector of the specified interrupt number.
                  *
                  *  \param number: Valid range [0-31].  Interrupt number
                  *
                  * \return
                  *  The address of the ISR in the interrupt vector table.
                  *
                  *******************************************************************************/
                  cyisraddress CyIntGetVector(uint8 number)
                  {
                      cyisraddress *ramVectorTable = *CY_INT_VECT_TABLE;
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
              
                      return (ramVectorTable[CY_INT_IRQ_BASE + (number & CY_INT_NUMBER_MASK)]);
                  }
              
              
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 37  

                  /*******************************************************************************
                  * Function Name: CyIntSetPriority
                  ****************************************************************************//**
                  *
                  *  Sets the Priority of the Interrupt.
                  *
                  *  \param priority: Priority of the interrupt. 0 - 7, 0 being the highest.
                  *  \param number: The number of the interrupt, 0 - 31.
                  *
                  *******************************************************************************/
                  void CyIntSetPriority(uint8 number, uint8 priority)
                  {
                      CYASSERT(priority <= CY_INT_PRIORITY_MAX);
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
                      CY_INT_PRIORITY_PTR[number & CY_INT_NUMBER_MASK] = (priority & CY_INT_PRIORITY_MASK)<< 5;
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntGetPriority
                  ****************************************************************************//**
                  *
                  *  Gets the Priority of the Interrupt.
                  *
                  *  \param number: The number of the interrupt, 0 - 31.
                  *
                  * \return
                  *  Priority of the interrupt. 0 - 7, 0 being the highest.
                  *
                  *******************************************************************************/
                  uint8 CyIntGetPriority(uint8 number)
                  {
                      uint8 priority;
              
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
              
                      priority = CY_INT_PRIORITY_PTR[number & CY_INT_NUMBER_MASK] >> 5;
              
                      return (priority);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntGetState
                  ****************************************************************************//**
                  *
                  *   Gets the enable state of the specified interrupt number.
                  *
                  *   \param number: Valid range [0-31].  Interrupt number.
                  *
                  * \return
                  *   Enable status: 1 if enabled, 0 if disabled
                  *
                  *******************************************************************************/
                  uint8 CyIntGetState(uint8 number)
                  {
                      reg32 * stateReg;
              
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
              
                      /* Get pointer to Interrupt enable register. */
                      stateReg = CY_INT_ENABLE_PTR;
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 38  

              
                      /* Get state of interrupt. */
                      return (0u != (*stateReg & (((uint32) 1u) << (0x1Fu & number)))) ? ((uint8)(1u)) : ((uint8)(0u));
                  }
              
              
              #else   /* PSoC3 */
2292          
2293              /*******************************************************************************
2294              * Function Name: IntDefaultHandler
2295              ****************************************************************************//**
2296              *
2297              *  This function is called for all interrupts, other than a reset that gets
2298              *  called before the system is setup.
2299              *
2300              * Theory:
2301              *  Any value other than zero is acceptable.
2302              *
2303              *******************************************************************************/
2304              CY_ISR(IntDefaultHandler)
2305              {
2306   1              #ifdef CY_BOOT_INT_DEFAULT_HANDLER_EXCEPTION_ENTRY_CALLBACK
                          CyBoot_IntDefaultHandler_Exception_EntryCallback();
                      #endif /* CY_BOOT_INT_DEFAULT_HANDLER_EXCEPTION_ENTRY_CALLBACK */
2309   1      
2310   1              while(1)
2311   1              {
2312   2                  /***********************************************************************
2313   2                  * We must not get here. If we do, a serious problem occurs, so go
2314   2                  * into an infinite loop.
2315   2                  ***********************************************************************/
2316   2              }
2317   1          }
2318          
2319          
2320              /*******************************************************************************
2321              * Function Name: IntDefaultHandler
2322              ****************************************************************************//**
2323              *
2324              *  This function is called during startup to initialize interrupt address vector
2325              *  registers with the address of the IntDefaultHandler().
2326              *
2327              *******************************************************************************/
2328              void CyIntInitVectors(void) 
2329              {
2330   1              uint8 i;
2331   1      
2332   1              for (i = 0; i <= CY_INT_NUMBER_MAX; i++)
2333   1              {
2334   2                  CY_SET_REG16(&CY_INT_VECT_TABLE[i], (uint16) &IntDefaultHandler);
2335   2              }
2336   1          }
2337          
2338          
2339              /*******************************************************************************
2340              * Function Name: CyIntSetVector
2341              ****************************************************************************//**
2342              *
2343              *  Sets the interrupt vector of the specified interrupt number.
2344              *
2345              *  \param number:  Valid range [0-31].  Interrupt number
2346              *  \param address: Pointer to an interrupt service routine
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 39  

2347              *
2348              * \return
2349              *  Previous interrupt vector value.
2350              *
2351              *******************************************************************************/
2352              cyisraddress CyIntSetVector(uint8 number, cyisraddress address) 
2353              {
2354   1              cyisraddress oldIsr;
2355   1      
2356   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2357   1      
2358   1              /* Save old Interrupt service routine. */
2359   1              oldIsr = (cyisraddress) \
2360   1                          CY_GET_REG16(&CY_INT_VECT_TABLE[number & CY_INT_NUMBER_MASK]);
2361   1      
2362   1              /* Set new Interrupt service routine. */
2363   1              CY_SET_REG16(&CY_INT_VECT_TABLE[number], (uint16) address);
2364   1      
2365   1              return (oldIsr);
2366   1          }
2367          
2368          
2369              /*******************************************************************************
2370              * Function Name: CyIntGetVector
2371              ****************************************************************************//**
2372              *
2373              *  Gets the interrupt vector of the specified interrupt number.
2374              *
2375              *  \param number: Valid range [0-31].  Interrupt number
2376              *
2377              * \return
2378              *  Address of the ISR in the interrupt vector table.
2379              *
2380              *******************************************************************************/
2381              cyisraddress CyIntGetVector(uint8 number) 
2382              {
2383   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2384   1      
2385   1              return ((cyisraddress) \
2386   1                      CY_GET_REG16(&CY_INT_VECT_TABLE[number & CY_INT_NUMBER_MASK]));
2387   1          }
2388          
2389          
2390              /*******************************************************************************
2391              * Function Name: CyIntSetPriority
2392              ****************************************************************************//**
2393              *
2394              *  Sets the Priority of the Interrupt.
2395              *
2396              *  \param priority: Priority of the interrupt. 0 - 7, 0 being the highest.
2397              *  \param number:   The number of the interrupt, 0 - 31.
2398              *
2399              *******************************************************************************/
2400              void CyIntSetPriority(uint8 number, uint8 priority) 
2401              {
2402   1              CYASSERT(priority <= CY_INT_PRIORITY_MAX);
2403   1      
2404   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2405   1      
2406   1              CY_INT_PRIORITY_PTR[number & CY_INT_NUMBER_MASK] =
2407   1                          (priority & CY_INT_PRIORITY_MASK) << 5;
2408   1          }
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 40  

2409          
2410          
2411              /*******************************************************************************
2412              * Function Name: CyIntGetPriority
2413              ****************************************************************************//**
2414              *
2415              *  Gets the Priority of the Interrupt.
2416              *
2417              *  \param number: The number of the interrupt, 0 - 31.
2418              *
2419              * \return
2420              *  Priority of the interrupt. 0 - 7, 0 being the highest.
2421              *
2422              *******************************************************************************/
2423              uint8 CyIntGetPriority(uint8 number) 
2424              {
2425   1              uint8 priority;
2426   1      
2427   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2428   1      
2429   1              priority = CY_INT_PRIORITY_PTR[number & CY_INT_NUMBER_MASK] >> 5;
2430   1      
2431   1              return (priority);
2432   1          }
2433          
2434          
2435              /*******************************************************************************
2436              * Function Name: CyIntGetState
2437              ****************************************************************************//**
2438              *
2439              *   Gets the enable state of the specified interrupt number.
2440              *
2441              *   \param number: Valid range [0-31].  Interrupt number.
2442              *
2443              * \return
2444              *   Enable status: 1 if enabled, 0 if disabled
2445              *
2446              *******************************************************************************/
2447              uint8 CyIntGetState(uint8 number) 
2448              {
2449   1              reg8 * stateReg;
2450   1      
2451   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2452   1      
2453   1              /* Get pointer to Interrupt enable register. */
2454   1              stateReg = CY_INT_ENABLE_PTR + ((number & CY_INT_NUMBER_MASK) >> 3u);
2455   1      
2456   1              /* Get state of interrupt. */
2457   1              return ((0u != (*stateReg & ((uint8)(1u << (0x07u & number))))) ? ((uint8)(1u)) : ((uint8)(0u)));
2458   1          }
2459          
2460          #endif  /* (CY_PSOC5) */
2461          
2462          
2463          #if(CYDEV_VARIABLE_VDDA == 1)
              
                  /*******************************************************************************
                  * Function Name: CySetScPumps
                  ****************************************************************************//**
                  *
                  *  If 1 is passed as a parameter:
                  *   - if any of the SC blocks are used - enable pumps for the SC blocks and
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 41  

                  *     start boost clock.
                  *   - For each enabled SC block set a boost clock index and enable the boost
                  *     clock.
                  *
                  *  If non-1 value is passed as a parameter:
                  *   - If all SC blocks are not used - disable pumps for the SC blocks and
                  *     stop the boost clock.
                  *   - For each enabled SC block clear the boost clock index and disable the
                  *     boost clock.
                  *
                  *  The global variable CyScPumpEnabled is updated to be equal to passed the
                  *  parameter.
                  *
                  *   \param uint8 enable: Enable/disable SC pumps and the boost clock for the enabled
                  *                 \param SC block:
                  *                 1 - Enable
                  *                 0 - Disable
                  *
                  *******************************************************************************/
                  void CySetScPumps(uint8 enable) 
                  {
                      if(1u == enable)
                      {
                          /* The SC pumps should be enabled */
                          CyScPumpEnabled = 1u;
                          /* Enable pumps if any of SC blocks are used */
                          if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAPS_MASK))
                          {
                              CY_LIB_SC_MISC_REG |= CY_LIB_SC_MISC_PUMP_FORCE;
                              CyScBoostClk_Start();
                          }
                          /* Set positive pump for each enabled SC block: set clock index and enable it */
                          if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAP0_EN))
                          {
                              CY_LIB_SC0_BST_REG = (CY_LIB_SC0_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK) | CyScBoostClk__I
             -NDEX;
                              CY_LIB_SC0_BST_REG |= CY_LIB_SC_BST_CLK_EN;
                          }
                          if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAP1_EN))
                          {
                              CY_LIB_SC1_BST_REG = (CY_LIB_SC1_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK) | CyScBoostClk__I
             -NDEX;
                              CY_LIB_SC1_BST_REG |= CY_LIB_SC_BST_CLK_EN;
                          }
                          if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAP2_EN))
                          {
                              CY_LIB_SC2_BST_REG = (CY_LIB_SC2_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK) | CyScBoostClk__I
             -NDEX;
                              CY_LIB_SC2_BST_REG |= CY_LIB_SC_BST_CLK_EN;
                          }
                          if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAP3_EN))
                          {
                              CY_LIB_SC3_BST_REG = (CY_LIB_SC3_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK) | CyScBoostClk__I
             -NDEX;
                              CY_LIB_SC3_BST_REG |= CY_LIB_SC_BST_CLK_EN;
                          }
                      }
                      else
                      {
                          /* The SC pumps should be disabled */
                          CyScPumpEnabled = 0u;
                          /* Disable pumps for all SC blocks and stop boost clock */
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 42  

                          CY_LIB_SC_MISC_REG &= ((uint8)(~CY_LIB_SC_MISC_PUMP_FORCE));
                          CyScBoostClk_Stop();
                          /* Disable boost clock and clear clock index for each SC block */
                          CY_LIB_SC0_BST_REG &= ((uint8)(~CY_LIB_SC_BST_CLK_EN));
                          CY_LIB_SC0_BST_REG = CY_LIB_SC0_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK;
                          CY_LIB_SC1_BST_REG &= ((uint8)(~CY_LIB_SC_BST_CLK_EN));
                          CY_LIB_SC1_BST_REG = CY_LIB_SC1_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK;
                          CY_LIB_SC2_BST_REG &= ((uint8)(~CY_LIB_SC_BST_CLK_EN));
                          CY_LIB_SC2_BST_REG = CY_LIB_SC2_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK;
                          CY_LIB_SC3_BST_REG &= ((uint8)(~CY_LIB_SC_BST_CLK_EN));
                          CY_LIB_SC3_BST_REG = CY_LIB_SC3_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK;
                      }
                  }
              
              #endif  /* (CYDEV_VARIABLE_VDDA == 1) */
2544          
2545          
2546          #if(CY_PSOC5)
                  /*******************************************************************************
                  * Function Name: CySysTickStart
                  ****************************************************************************//**
                  *
                  *  Configures the SysTick timer to generate interrupt every 1 ms by call to the
                  *  CySysTickInit() function and starts it by calling CySysTickEnable() function.
                  *  Refer to the corresponding function description for the details.
              
                  * \sideeffect
                  *  Clears SysTick count flag if it was set
                  *
                  *******************************************************************************/
                  void CySysTickStart(void)
                  {
                      if (0u == CySysTickInitVar)
                      {
                          CySysTickInit();
                          CySysTickInitVar = 1u;
                      }
              
                      CySysTickEnable();
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickInit
                  ****************************************************************************//**
                  *
                  *  Initializes the callback addresses with pointers to NULL, associates the
                  *  SysTick system vector with the function that is responsible for calling
                  *  registered callback functions, configures SysTick timer to generate interrupt
                  * every 1 ms.
                  *
                  * \sideeffect
                  *  Clears SysTick count flag if it was set.
                  *
                  *  The 1 ms interrupt interval is configured based on the frequency determined
                  *  by PSoC Creator at build time. If System clock frequency is changed in
                  *  runtime, the CyDelayFreq() with the appropriate parameter should be called.
                  *
                  *******************************************************************************/
                  void CySysTickInit(void)
                  {
                      uint32 i;
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 43  

              
                      for (i = 0u; i<CY_SYS_SYST_NUM_OF_CALLBACKS; i++)
                      {
                          CySysTickCallbacks[i] = (void *) 0;
                      }
              
                      (void) CyIntSetSysVector(CY_INT_SYSTICK_IRQN, &CySysTickServiceCallbacks);
                      CySysTickSetClockSource(CY_SYS_SYST_CSR_CLK_SRC_SYSCLK);
                      CySysTickSetReload(cydelay_freq_hz/1000u);
                      CySysTickClear();
                      CyIntEnable(CY_INT_SYSTICK_IRQN);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickEnable
                  ****************************************************************************//**
                  *
                  *  Enables the SysTick timer and its interrupt.
                  *
                  * \sideeffect
                  *  Clears SysTick count flag if it was set
                  *
                  *******************************************************************************/
                  void CySysTickEnable(void)
                  {
                      CySysTickEnableInterrupt();
                      CY_SYS_SYST_CSR_REG |= CY_SYS_SYST_CSR_ENABLE;
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickStop
                  ****************************************************************************//**
                  *
                  *  Stops the system timer (SysTick).
                  *
                  * \sideeffect
                  *  Clears SysTick count flag if it was set
                  *
                  *******************************************************************************/
                  void CySysTickStop(void)
                  {
                      CY_SYS_SYST_CSR_REG &= ((uint32) ~(CY_SYS_SYST_CSR_ENABLE));
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickEnableInterrupt
                  ****************************************************************************//**
                  *
                  *  Enables the SysTick interrupt.
                  *
                  * \sideeffect
                  *  Clears SysTick count flag if it was set
                  *
                  *******************************************************************************/
                  void CySysTickEnableInterrupt(void)
                  {
                      CY_SYS_SYST_CSR_REG |= CY_SYS_SYST_CSR_ENABLE_INT;
                  }
              
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 44  

              
                  /*******************************************************************************
                  * Function Name: CySysTickDisableInterrupt
                  ****************************************************************************//**
                  *
                  *  Disables the SysTick interrupt.
                  *
                  * \sideeffect
                  *  Clears SysTick count flag if it was set
                  *
                  *******************************************************************************/
                  void CySysTickDisableInterrupt(void)
                  {
                      CY_SYS_SYST_CSR_REG &= ((uint32) ~(CY_SYS_SYST_CSR_ENABLE_INT));
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickSetReload
                  ****************************************************************************//**
                  *
                  *  Sets value the counter is set to on startup and after it reaches zero. This
                  *  function do not change or reset current sysTick counter value, so it should
                  *  be cleared using CySysTickClear() API.
                  *
                  *  \param value: Valid range [0x0-0x00FFFFFF]. Counter reset value.
                  *
                  *******************************************************************************/
                  void CySysTickSetReload(uint32 value)
                  {
                      CY_SYS_SYST_RVR_REG = (value & CY_SYS_SYST_RVR_CNT_MASK);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickGetReload
                  ****************************************************************************//**
                  *
                  *  Sets value the counter is set to on startup and after it reaches zero.
                  *
                  * \return
                  *  Counter reset value
                  *
                  *******************************************************************************/
                  uint32 CySysTickGetReload(void)
                  {
                      return(CY_SYS_SYST_RVR_REG & CY_SYS_SYST_RVR_CNT_MASK);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickGetValue
                  ****************************************************************************//**
                  *
                  *  Gets current SysTick counter value.
                  *
                  * \return
                  *  Current SysTick counter value
                  *
                  *******************************************************************************/
                  uint32 CySysTickGetValue(void)
                  {
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 45  

                      return(CY_SYS_SYST_CVR_REG & CY_SYS_SYST_CVR_CNT_MASK);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickSetClockSource
                  ****************************************************************************//**
                  *
                  *  Sets the clock source for the SysTick counter.
                  *
                  *  \param clockSource: Clock source for SysTick counter
                  *         Define                     Clock Source
                  *   CY_SYS_SYST_CSR_CLK_SRC_SYSCLK     SysTick is clocked by CPU clock.
                  *   CY_SYS_SYST_CSR_CLK_SRC_LFCLK      SysTick is clocked by the low frequency
                  *                                      clock (ILO 100 KHz for PSoC 5LP, and
                  *                                      LFCLK for PSoC 4).
                  *
                  * \sideeffect
                  *  Clears SysTick count flag if it was set. If clock source is not ready this
                  *  function call will have no effect. After changing clock source to the low
                  *  frequency clock the counter and reload register values will remain unchanged
                  *  so time to the interrupt will be significantly bigger and vice versa.
                  *
                  *******************************************************************************/
                  void CySysTickSetClockSource(uint32 clockSource)
                  {
                      if (clockSource == CY_SYS_SYST_CSR_CLK_SRC_SYSCLK)
                      {
                          CY_SYS_SYST_CSR_REG |= (uint32)(CY_SYS_SYST_CSR_CLK_SRC_SYSCLK << CY_SYS_SYST_CSR_CLK_SOURCE_S
             -HIFT);
                      }
                      else
                      {
                          CY_SYS_SYST_CSR_REG &= ((uint32) ~((uint32)(CY_SYS_SYST_CSR_CLK_SRC_SYSCLK << CY_SYS_SYST_CSR_
             -CLK_SOURCE_SHIFT)));
                      }
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickGetCountFlag
                  ****************************************************************************//**
                  *
                  *  The count flag is set once SysTick counter reaches zero.
                  *   The flag cleared on read.
                  *
                  * \return
                  *  Returns non-zero value if flag is set, otherwise zero is returned.
                  *
                  *
                  * \sideeffect
                  *  Clears SysTick count flag if it was set.
                  *
                  *******************************************************************************/
                  uint32 CySysTickGetCountFlag(void)
                  {
                      return ((CY_SYS_SYST_CSR_REG >> CY_SYS_SYST_CSR_COUNTFLAG_SHIFT) & 0x01u);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickClear
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 46  

                  ****************************************************************************//**
                  *
                  *  Clears the SysTick counter for well-defined startup.
                  *
                  *******************************************************************************/
                  void CySysTickClear(void)
                  {
                      CY_SYS_SYST_CVR_REG = 0u;
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickSetCallback
                  ****************************************************************************//**
                  *
                  *  This function allows up to five user-defined interrupt service routine
                  *  functions to be associated with the SysTick interrupt. These are specified
                  *  through the use of pointers to the function.
                  *
                  *  To set a custom callback function without the overhead of the system provided
                  *  one, use CyIntSetSysVector(CY_INT_SYSTICK_IRQN, cyisraddress <address>),
                  *  where <address> is address of the custom defined interrupt service routine.
                  *  Note: a custom callback function overrides the system defined callback
                  *  functions.
                  *
                  *  \param number: The number of the callback function addresses to be set. The valid
                  *          range is from 0 to 4.
                  *
                  *  void(*CallbackFunction(void): A pointer to the function that will be
                  *                                associated with the SysTick ISR for the
                  *                                specified number.
                  *
                  * \return
                  *  Returns the address of the previous callback function.
                  *  The NULL is returned if the specified address in not set.
                  *
                  * \sideeffect
                  *  The registered callback functions will be executed in the interrupt.
                  *
                  *******************************************************************************/
                  cySysTickCallback CySysTickSetCallback(uint32 number, cySysTickCallback function)
                  {
                      cySysTickCallback retVal;
              
                      retVal = CySysTickCallbacks[number];
                      CySysTickCallbacks[number] = function;
                      return (retVal);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickGetCallback
                  ****************************************************************************//**
                  *
                  *  The function get the specified callback pointer.
                  *
                  *  \param number: The number of callback function address to get. The valid
                  *          range is from 0 to 4.
                  *
                  * \return
                  *  Returns the address of the specified callback function.
                  *  The NULL is returned if the specified address in not initialized.
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 47  

                  *
                  *******************************************************************************/
                  cySysTickCallback CySysTickGetCallback(uint32 number)
                  {
                      return ((cySysTickCallback) CySysTickCallbacks[number]);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickServiceCallbacks
                  ****************************************************************************//**
                  *
                  *  System Tick timer interrupt routine
                  *
                  *******************************************************************************/
                  static void CySysTickServiceCallbacks(void)
                  {
                      uint32 i;
              
                      /* Verify that tick timer flag was set */
                      if (1u == CySysTickGetCountFlag())
                      {
                          for (i=0u; i < CY_SYS_SYST_NUM_OF_CALLBACKS; i++)
                          {
                              if (CySysTickCallbacks[i] != (void *) 0)
                              {
                                  (void)(CySysTickCallbacks[i])();
                              }
                          }
                      }
                  }
              #endif /* (CY_PSOC5) */
2869          
2870          
2871          /*******************************************************************************
2872          * Function Name: CyGetUniqueId
2873          ****************************************************************************//**
2874          *
2875          *  Returns the 64-bit unique ID of the device. The uniqueness of the number is
2876          *  guaranteed for 10 years due to the die lot number having a cycle life of 10
2877          *  years and even after 10 years, the probability of getting two identical
2878          *  numbers is very small.
2879          *
2880          *  \param uniqueId: The pointer to a two element 32-bit unsigned integer array. Returns
2881          *  the 64-bit unique ID of the device by loading them into the integer array
2882          *  pointed to by uniqueId.
2883          *
2884          *******************************************************************************/
2885          void CyGetUniqueId(uint32* uniqueId)
2886          {
2887   1      #if(CY_PSOC4)
                  uniqueId[0u]  =  (uint32)(* (reg8 *) CYREG_SFLASH_DIE_LOT0  );
                  uniqueId[0u] |= ((uint32)(* (reg8 *) CYREG_SFLASH_DIE_LOT1  ) <<  8u);
                  uniqueId[0u] |= ((uint32)(* (reg8 *) CYREG_SFLASH_DIE_LOT2  ) << 16u);
                  uniqueId[0u] |= ((uint32)(* (reg8 *) CYREG_SFLASH_DIE_WAFER ) << 24u);
              
                  uniqueId[1u]  =  (uint32)(* (reg8 *) CYREG_SFLASH_DIE_X     );
                  uniqueId[1u] |= ((uint32)(* (reg8 *) CYREG_SFLASH_DIE_Y     ) <<  8u);
                  uniqueId[1u] |= ((uint32)(* (reg8 *) CYREG_SFLASH_DIE_SORT  ) << 16u);
                  uniqueId[1u] |= ((uint32)(* (reg8 *) CYREG_SFLASH_DIE_MINOR ) << 24u);
              #else
2898   1          uniqueId[0u]  =  (uint32) CY_GET_XTND_REG8((void CYFAR *) (CYREG_FLSHID_CUST_TABLES_LOT_LSB   ));
C51 COMPILER V9.51   CYLIB                                                                 03/16/2018 17:06:28 PAGE 48  

2899   1          uniqueId[0u] |= ((uint32) CY_GET_XTND_REG8((void CYFAR *) (CYREG_FLSHID_CUST_TABLES_LOT_MSB   )) <<  8
             -u);
2900   1          uniqueId[0u] |= ((uint32) CY_GET_XTND_REG8((void CYFAR *) (CYREG_MLOGIC_REV_ID                )) << 16
             -u);
2901   1          uniqueId[0u] |= ((uint32) CY_GET_XTND_REG8((void CYFAR *) (CYREG_FLSHID_CUST_TABLES_WAFER_NUM )) << 24
             -u);
2902   1      
2903   1          uniqueId[1u]  =  (uint32) CY_GET_XTND_REG8((void CYFAR *) (CYREG_FLSHID_CUST_TABLES_X_LOC     ));
2904   1          uniqueId[1u] |= ((uint32) CY_GET_XTND_REG8((void CYFAR *) (CYREG_FLSHID_CUST_TABLES_Y_LOC     )) <<  8
             -u);
2905   1          uniqueId[1u] |= ((uint32) CY_GET_XTND_REG8((void CYFAR *) (CYREG_FLSHID_CUST_TABLES_WRK_WK    )) << 16
             -u);
2906   1          uniqueId[1u] |= ((uint32) CY_GET_XTND_REG8((void CYFAR *) (CYREG_FLSHID_CUST_TABLES_FAB_YR    )) << 24
             -u);
2907   1      #endif  /* (CY_PSOC4) */
2908   1      }
2909          
2910          /* [] END OF FILE */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5307    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    117    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
