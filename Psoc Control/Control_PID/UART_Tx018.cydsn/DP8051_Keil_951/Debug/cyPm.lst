C51 COMPILER V9.51   CYPM                                                                  03/16/2018 17:06:28 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE CYPM
OBJECT MODULE PLACED IN .\DP8051_Keil_951\Debug\cyPm.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Cypress\PSoC Creator\4.2\PSoC Creator\import\keil\pk51\9.51\C51\BIN\c51.exe 
                    -Generated_Source\PSoC3\cyPm.c NOIV LARGE MODDP2 OMF2 VB(1) NOIP INCDIR(.,Generated_Source\PSoC3) FF(3) DB WL(2) PR(.\DP8
                    -051_Keil_951\Debug/cyPm.lst) OT(0) OJ(.\DP8051_Keil_951\Debug\cyPm.obj)

line level    source

   1          /***************************************************************************//**
   2          * \file cyPm.c
   3          * \version 5.70
   4          *
   5          * \brief Provides an API for the power management.
   6          *
   7          * \note Documentation of the API's in this file is located in the
   8          *  System Reference Guide provided with PSoC Creator.
   9          *
  10          ********************************************************************************
  11          * \copyright
  12          * Copyright 2008-2018, Cypress Semiconductor Corporation.  All rights reserved.
  13          * You may use this file only in accordance with the license, terms, conditions,
  14          * disclaimers, and limitations in the end user license agreement accompanying
  15          * the software package with which this file was provided.
  16          *******************************************************************************/
  17          
  18          #include "cyPm.h"
  19          #include "cyapicallbacks.h"
  20          
  21          
  22          /*******************************************************************
  23          * Place your includes, defines, and code here. Do not use the merge
  24          * region below unless any component datasheet suggests doing so.
  25          *******************************************************************/
  26          /* `#START CY_PM_HEADER_INCLUDE` */
  27          
  28          /* `#END` */
  29          
  30          
  31          static CY_PM_BACKUP_STRUCT          cyPmBackup;
  32          static CY_PM_CLOCK_BACKUP_STRUCT    cyPmClockBackup;
  33          
  34          /* Convertion table between register's values and frequency in MHz  */
  35          static const uint8 CYCODE cyPmImoFreqReg2Mhz[7u] = {12u, 6u, 24u, 3u, 48u, 62u, 74u};
  36          
  37          /* Function Prototypes */
  38          static void CyPmHibSaveSet(void);
  39          static void CyPmHibRestore(void) ;
  40          
  41          static void CyPmHibSlpSaveSet(void) ;
  42          static void CyPmHibSlpRestore(void) ;
  43          
  44          static void CyPmHviLviSaveDisable(void) ;
  45          static void CyPmHviLviRestore(void) ;
  46          
  47          
  48          /*******************************************************************************
  49          * Function Name: CyPmSaveClocks
  50          ****************************************************************************//**
  51          *
  52          *  This function is called in preparation for entering sleep or hibernate low
  53          *  power modes. Saves all the states of the clocking system that do not persist
C51 COMPILER V9.51   CYPM                                                                  03/16/2018 17:06:28 PAGE 2   

  54          *  during sleep/hibernate or that need to be altered in preparation for
  55          *  sleep/hibernate. Shutdowns all the digital and analog clock dividers for the
  56          *  active power mode configuration.
  57          *
  58          *  Switches the master clock over to the IMO and shuts down the PLL and MHz
  59          *  Crystal. The IMO frequency is set to either 12 MHz or 48 MHz to match the
  60          *  Design-Wide Resources System Editor "Enable Fast IMO During Startup" setting.
  61          *  The ILO and 32 KHz oscillators are not impacted. The current Flash wait state
  62          *  setting is saved and the Flash wait state setting is set for the current IMO
  63          *  speed.
  64          *
  65          *  Note If the Master Clock source is routed through the DSI inputs, then it
  66          *  must be set manually to another source before using the
  67          *  CyPmSaveClocks()/CyPmRestoreClocks() functions.
  68          *
  69          * \sideeffect
  70          *  All peripheral clocks are going to be off after this API method call.
  71          *
  72          *******************************************************************************/
  73          void CyPmSaveClocks(void) 
  74          {
  75   1          /* Digital and analog clocks - save enable state and disable them all */
  76   1          cyPmClockBackup.enClkA = CY_PM_ACT_CFG1_REG & CY_PM_ACT_EN_CLK_A_MASK;
  77   1          cyPmClockBackup.enClkD = CY_PM_ACT_CFG2_REG;
  78   1          CY_PM_ACT_CFG1_REG &= ((uint8)(~CY_PM_ACT_EN_CLK_A_MASK));
  79   1          CY_PM_ACT_CFG2_REG &= ((uint8)(~CY_PM_ACT_EN_CLK_D_MASK));
  80   1      
  81   1          /* Save current flash wait cycles and set the maximum value */
  82   1          cyPmClockBackup.flashWaitCycles = CY_PM_CACHE_CR_CYCLES_MASK & CY_PM_CACHE_CR_REG;
  83   1          CyFlash_SetWaitCycles(CY_PM_MAX_FLASH_WAIT_CYCLES);
  84   1      
  85   1          /* IMO - save current IMO MHz OSC frequency and USB mode is on bit */
  86   1          cyPmClockBackup.imoFreq = CY_PM_FASTCLK_IMO_CR_REG & CY_PM_FASTCLK_IMO_CR_FREQ_MASK;
  87   1          cyPmClockBackup.imoUsbClk = CY_PM_FASTCLK_IMO_CR_REG & CY_PM_FASTCLK_IMO_CR_USB;
  88   1      
  89   1          /* IMO doubler - save enable state */
  90   1          if(0u != (CY_PM_FASTCLK_IMO_CR_REG & CY_PM_FASTCLK_IMO_CR_F2XON))
  91   1          {
  92   2              /* IMO doubler enabled - save and disable */
  93   2              cyPmClockBackup.imo2x = CY_PM_ENABLED;
  94   2          }
  95   1          else
  96   1          {
  97   2              /* IMO doubler disabled */
  98   2              cyPmClockBackup.imo2x = CY_PM_DISABLED;
  99   2          }
 100   1      
 101   1          /* Master clock - save source */
 102   1          cyPmClockBackup.masterClkSrc = CY_PM_CLKDIST_MSTR1_REG & CY_PM_MASTER_CLK_SRC_MASK;
 103   1      
 104   1          /* Switch Master clock's source from PLL's output to PLL's source */
 105   1          if(CY_MASTER_SOURCE_PLL == cyPmClockBackup.masterClkSrc)
 106   1          {
 107   2              switch (CY_PM_CLKDIST_CR_REG & CY_PM_CLKDIST_PLL_SRC_MASK)
 108   2              {
 109   3              case CY_PM_CLKDIST_PLL_SRC_IMO:
 110   3                  CyMasterClk_SetSource(CY_MASTER_SOURCE_IMO);
 111   3                  break;
 112   3      
 113   3              case CY_PM_CLKDIST_PLL_SRC_XTAL:
 114   3                  CyMasterClk_SetSource(CY_MASTER_SOURCE_XTAL);
 115   3                  break;
C51 COMPILER V9.51   CYPM                                                                  03/16/2018 17:06:28 PAGE 3   

 116   3      
 117   3              case CY_PM_CLKDIST_PLL_SRC_DSI:
 118   3                  CyMasterClk_SetSource(CY_MASTER_SOURCE_DSI);
 119   3                  break;
 120   3      
 121   3              default:
 122   3                  CYASSERT(0u != 0u);
 123   3                  break;
 124   3              }
 125   2          }
 126   1      
 127   1          /* PLL - check enable state, disable if needed */
 128   1          if(0u != (CY_PM_FASTCLK_PLL_CFG0_REG & CY_PM_PLL_CFG0_ENABLE))
 129   1          {
 130   2              /* PLL is enabled - save state and disable */
 131   2              cyPmClockBackup.pllEnableState = CY_PM_ENABLED;
 132   2              CyPLL_OUT_Stop();
 133   2          }
 134   1          else
 135   1          {
 136   2              /* PLL is disabled - save state */
 137   2              cyPmClockBackup.pllEnableState = CY_PM_DISABLED;
 138   2          }
 139   1      
 140   1          /* IMO - set appropriate frequency for LPM */
 141   1          CyIMO_SetFreq(CY_PM_IMO_FREQ_LPM);
 142   1      
 143   1          /* IMO - save enable state and enable without wait to settle */
 144   1          if(0u != (CY_PM_ACT_CFG0_IMO & CY_PM_ACT_CFG0_REG))
 145   1          {
 146   2              /* IMO - save enabled state */
 147   2              cyPmClockBackup.imoEnable = CY_PM_ENABLED;
 148   2          }
 149   1          else
 150   1          {
 151   2              /* IMO - save disabled state */
 152   2              cyPmClockBackup.imoEnable = CY_PM_DISABLED;
 153   2      
 154   2              /* Enable the IMO. Use software delay instead of the FTW-based inside */
 155   2              CyIMO_Start(CY_PM_IMO_NO_WAIT_TO_SETTLE);
 156   2      
 157   2              /* Settling time of the IMO is of the order of less than 6us */
 158   2              CyDelayUs(6u);
 159   2          }
 160   1      
 161   1          /* IMO - save the current IMOCLK source and set to IMO if not yet */
 162   1          if(0u != (CY_PM_FASTCLK_IMO_CR_REG & CY_PM_FASTCLK_IMO_CR_XCLKEN))
 163   1          {
 164   2              /* DSI or XTAL CLK */
 165   2              cyPmClockBackup.imoClkSrc =
 166   2                  (0u == (CY_PM_CLKDIST_CR_REG & CY_PM_CLKDIST_IMO2X_SRC)) ? CY_IMO_SOURCE_DSI : CY_IMO_SOURCE_X
             -TAL;
 167   2      
 168   2              /* IMO -  set IMOCLK source to IMO */
 169   2              CyIMO_SetSource(CY_IMO_SOURCE_IMO);
 170   2          }
 171   1          else
 172   1          {
 173   2              /* IMO */
 174   2              cyPmClockBackup.imoClkSrc = CY_IMO_SOURCE_IMO;
 175   2          }
 176   1      
C51 COMPILER V9.51   CYPM                                                                  03/16/2018 17:06:28 PAGE 4   

 177   1          /* Save clk_imo source */
 178   1          cyPmClockBackup.clkImoSrc = CY_PM_CLKDIST_CR_REG & CY_PM_CLKDIST_IMO_OUT_MASK;
 179   1      
 180   1          /* If IMOCLK2X or SPC OSC is source for clk_imo, set it to IMOCLK */
 181   1          if(CY_PM_CLKDIST_IMO_OUT_IMO != cyPmClockBackup.clkImoSrc)
 182   1          {
 183   2              /* Set IMOCLK to source for clk_imo */
 184   2              CY_PM_CLKDIST_CR_REG = (CY_PM_CLKDIST_CR_REG & ((uint8)(~CY_PM_CLKDIST_IMO_OUT_MASK))) |
 185   2                                      CY_PM_CLKDIST_IMO_OUT_IMO;
 186   2          }    /* Need to change nothing if IMOCLK is source clk_imo */
 187   1      
 188   1          /* IMO doubler - disable it (saved above) */
 189   1          if(0u != (CY_PM_FASTCLK_IMO_CR_REG & CY_PM_FASTCLK_IMO_CR_F2XON))
 190   1          {
 191   2              CyIMO_DisableDoubler();
 192   2          }
 193   1      
 194   1          /* Master clock - save divider and set it to divide-by-one (if no yet) */
 195   1          cyPmClockBackup.clkSyncDiv = CY_PM_CLKDIST_MSTR0_REG;
 196   1          if(CY_PM_DIV_BY_ONE != cyPmClockBackup.clkSyncDiv)
 197   1          {
 198   2              CyMasterClk_SetDivider(CY_PM_DIV_BY_ONE);
 199   2          }    /* No change if master clock divider is 1 */
 200   1      
 201   1          /* Master clock source - set it to IMO if not yet. */
 202   1          if(CY_MASTER_SOURCE_IMO != cyPmClockBackup.masterClkSrc)
 203   1          {
 204   2              CyMasterClk_SetSource(CY_MASTER_SOURCE_IMO);
 205   2          }    /* No change if master clock source is IMO */
 206   1      
 207   1          /* Bus clock - save divider and set it, if needed, to divide-by-one */
 208   1          cyPmClockBackup.clkBusDiv = (uint16) ((uint16) CY_PM_CLK_BUS_MSB_DIV_REG << 8u);
 209   1          cyPmClockBackup.clkBusDiv |= CY_PM_CLK_BUS_LSB_DIV_REG;
 210   1          if(CY_PM_BUS_CLK_DIV_BY_ONE != cyPmClockBackup.clkBusDiv)
 211   1          {
 212   2              CyBusClk_SetDivider(CY_PM_BUS_CLK_DIV_BY_ONE);
 213   2          }    /* Do nothing if saved and actual values are equal */
 214   1      
 215   1          /* Set number of wait cycles for flash according to CPU frequency in MHz */
 216   1          CyFlash_SetWaitCycles((uint8)CY_PM_GET_CPU_FREQ_MHZ);
 217   1      
 218   1          /* MHz ECO - check enable state and disable if needed */
 219   1          if(0u != (CY_PM_FASTCLK_XMHZ_CSR_REG & CY_PM_XMHZ_CSR_ENABLE))
 220   1          {
 221   2              /* MHz ECO is enabled - save state and disable */
 222   2              cyPmClockBackup.xmhzEnableState = CY_PM_ENABLED;
 223   2              CyXTAL_Stop();
 224   2          }
 225   1          else
 226   1          {
 227   2              /* MHz ECO is disabled - save state */
 228   2              cyPmClockBackup.xmhzEnableState = CY_PM_DISABLED;
 229   2          }
 230   1      
 231   1      
 232   1          /***************************************************************************
 233   1          * Save the enable state of delay between the system bus clock and each of the
 234   1          * 4 individual analog clocks. This bit non-retention and its value should
 235   1          * be restored on wakeup.
 236   1          ***************************************************************************/
 237   1          if(0u != (CY_PM_CLKDIST_DELAY_REG & CY_PM_CLKDIST_DELAY_EN))
 238   1          {
C51 COMPILER V9.51   CYPM                                                                  03/16/2018 17:06:28 PAGE 5   

 239   2              cyPmClockBackup.clkDistDelay = CY_PM_ENABLED;
 240   2          }
 241   1          else
 242   1          {
 243   2              cyPmClockBackup.clkDistDelay = CY_PM_DISABLED;
 244   2          }
 245   1      }
 246          
 247          
 248          /*******************************************************************************
 249          * Function Name: CyPmRestoreClocks
 250          ****************************************************************************//**
 251          *
 252          *  Restores any state that was preserved by the last call to CyPmSaveClocks().
 253          *  The Flash wait state setting is also restored.
 254          *
 255          *  Note If the Master Clock source is routed through the DSI inputs, then it
 256          *  must be set manually to another source before using the
 257          *  CyPmSaveClocks()/CyPmRestoreClocks() functions.
 258          *
 259          *  PSoC 3 and PSoC 5LP:
 260          *  The merge region could be used to process state when the megahertz crystal is
 261          *  not ready after a hold-off timeout.
 262          *
 263          *  PSoC 5:
 264          *  The 130 ms is given for the megahertz crystal to stabilize. Its readiness is
 265          *  not verified after a hold-off timeout.
 266          *
 267          *******************************************************************************/
 268          void CyPmRestoreClocks(void) 
 269          {
 270   1          cystatus status = CYRET_TIMEOUT;
 271   1          uint16 i;
 272   1          uint16 clkBusDivTmp;
 273   1      
 274   1      
 275   1          /* Convertion table between CyIMO_SetFreq() parameters and register's value */
 276   1          const uint8 CYCODE cyPmImoFreqMhz2Reg[7u] = {
 277   1              CY_IMO_FREQ_12MHZ, CY_IMO_FREQ_6MHZ,  CY_IMO_FREQ_24MHZ, CY_IMO_FREQ_3MHZ,
 278   1              CY_IMO_FREQ_48MHZ, 5u, 6u};
 279   1      
 280   1          /* Restore enable state of delay between system bus clock and ACLKs. */
 281   1          if(CY_PM_ENABLED == cyPmClockBackup.clkDistDelay)
 282   1          {
 283   2              /* Delay for both bandgap and delay line to settle out */
 284   2              CyDelayCycles((uint32)(CY_PM_CLK_DELAY_BANDGAP_SETTLE_US + CY_PM_CLK_DELAY_BIAS_SETTLE_US) *
 285   2                              CY_PM_GET_CPU_FREQ_MHZ);
 286   2      
 287   2              CY_PM_CLKDIST_DELAY_REG |= CY_PM_CLKDIST_DELAY_EN;
 288   2          }
 289   1      
 290   1          /* MHz ECO restore state */
 291   1          if(CY_PM_ENABLED == cyPmClockBackup.xmhzEnableState)
 292   1          {
 293   2              /***********************************************************************
 294   2              * Enabling XMHZ XTAL. The actual CyXTAL_Start() with a non zero wait
 295   2              * period uses FTW for period measurement. This could cause a problem
 296   2              * if CTW/FTW is used as a wake up time in the low power modes APIs.
 297   2              * So, the XTAL wait procedure is implemented with a software delay.
 298   2              ***********************************************************************/
 299   2      
 300   2              /* Enable XMHZ XTAL with no wait */
C51 COMPILER V9.51   CYPM                                                                  03/16/2018 17:06:28 PAGE 6   

 301   2              (void) CyXTAL_Start(CY_PM_XTAL_MHZ_NO_WAIT);
 302   2      
 303   2              /* Read XERR bit to clear it */
 304   2              (void) CY_PM_FASTCLK_XMHZ_CSR_REG;
 305   2      
 306   2              /* Wait */
 307   2              for(i = CY_PM_MHZ_XTAL_WAIT_NUM_OF_200_US; i > 0u; i--)
 308   2              {
 309   3                  /* Make a 200 microseconds delay */
 310   3                  CyDelayCycles((uint32)CY_PM_WAIT_200_US * CY_PM_GET_CPU_FREQ_MHZ);
 311   3      
 312   3                  /* High output indicates oscillator failure */
 313   3                  if(0u == (CY_PM_FASTCLK_XMHZ_CSR_REG & CY_PM_XMHZ_CSR_XERR))
 314   3                  {
 315   4                      status = CYRET_SUCCESS;
 316   4                      break;
 317   4                  }
 318   3              }
 319   2      
 320   2              if(CYRET_TIMEOUT == status)
 321   2              {
 322   3                  /*******************************************************************
 323   3                  * Process the situation when megahertz crystal is not ready.
 324   3                  * Time to stabilize the value is crystal specific.
 325   3                  *******************************************************************/
 326   3                 /* `#START_MHZ_ECO_TIMEOUT` */
 327   3      
 328   3                 /* `#END` */
 329   3      
 330   3              #ifdef CY_BOOT_CY_PM_RESTORE_CLOCKS_ECO_TIMEOUT_CALLBACK
                          CyBoot_CyPmRestoreClocks_EcoTimeout_Callback();
                      #endif /* CY_BOOT_CY_PM_RESTORE_CLOCKS_ECO_TIMEOUT_CALLBACK */
 333   3              }
 334   2          }   /* (CY_PM_ENABLED == cyPmClockBackup.xmhzEnableState) */
 335   1      
 336   1      
 337   1          /* Temporary set maximum flash wait cycles */
 338   1          CyFlash_SetWaitCycles(CY_PM_MAX_FLASH_WAIT_CYCLES);
 339   1      
 340   1          /* XTAL and DSI clocks are ready to be source for Master clock. */
 341   1          if((CY_PM_MASTER_CLK_SRC_XTAL == cyPmClockBackup.masterClkSrc) ||
 342   1             (CY_PM_MASTER_CLK_SRC_DSI  == cyPmClockBackup.masterClkSrc))
 343   1          {
 344   2              /* Restore Master clock's divider */
 345   2              if(CY_PM_CLKDIST_MSTR0_REG != cyPmClockBackup.clkSyncDiv)
 346   2              {
 347   3                  /* Restore Master clock divider */
 348   3                  CyMasterClk_SetDivider(cyPmClockBackup.clkSyncDiv);
 349   3              }
 350   2      
 351   2              /* Restore Master clock source */
 352   2              CyMasterClk_SetSource(cyPmClockBackup.masterClkSrc);
 353   2          }
 354   1      
 355   1          /* IMO - restore IMO frequency */
 356   1          if((0u != (cyPmClockBackup.imoUsbClk & CY_PM_FASTCLK_IMO_CR_USB)) &&
 357   1              (CY_IMO_FREQ_24MHZ == cyPmImoFreqMhz2Reg[cyPmClockBackup.imoFreq]))
 358   1          {
 359   2              /* Restore IMO frequency (24 MHz) and trim it for USB */
 360   2              CyIMO_SetFreq(CY_IMO_FREQ_USB);
 361   2          }
 362   1          else
C51 COMPILER V9.51   CYPM                                                                  03/16/2018 17:06:28 PAGE 7   

 363   1          {
 364   2              /* Restore IMO frequency */
 365   2              CyIMO_SetFreq(cyPmImoFreqMhz2Reg[cyPmClockBackup.imoFreq]);
 366   2      
 367   2              if(0u != (cyPmClockBackup.imoUsbClk & CY_PM_FASTCLK_IMO_CR_USB))
 368   2              {
 369   3                  CY_PM_FASTCLK_IMO_CR_REG |= CY_PM_FASTCLK_IMO_CR_USB;
 370   3              }
 371   2              else
 372   2              {
 373   3                  CY_PM_FASTCLK_IMO_CR_REG &= ((uint8)(~CY_PM_FASTCLK_IMO_CR_USB));
 374   3              }
 375   2          }
 376   1      
 377   1          /* IMO - restore enable state if needed */
 378   1          if((CY_PM_ENABLED == cyPmClockBackup.imoEnable) &&
 379   1             (0u == (CY_PM_ACT_CFG0_IMO & CY_PM_ACT_CFG0_REG)))
 380   1          {
 381   2              /* IMO - restore enabled state */
 382   2              CyIMO_Start(CY_PM_IMO_NO_WAIT_TO_SETTLE);
 383   2          }
 384   1      
 385   1          /* IMO - restore IMOCLK source */
 386   1          CyIMO_SetSource(cyPmClockBackup.imoClkSrc);
 387   1      
 388   1          /* Restore IMO doubler enable state (turned off by CyPmSaveClocks()) */
 389   1          if(CY_PM_ENABLED == cyPmClockBackup.imo2x)
 390   1          {
 391   2              CyIMO_EnableDoubler();
 392   2          }
 393   1      
 394   1          /* IMO - restore clk_imo source, if needed */
 395   1          if(cyPmClockBackup.clkImoSrc != (CY_PM_CLKDIST_CR_REG & CY_PM_CLKDIST_IMO_OUT_MASK))
 396   1          {
 397   2              CY_PM_CLKDIST_CR_REG = (CY_PM_CLKDIST_CR_REG & ((uint8)(~CY_PM_CLKDIST_IMO_OUT_MASK))) |
 398   2                                      cyPmClockBackup.clkImoSrc;
 399   2          }
 400   1      
 401   1      
 402   1          /* PLL restore state */
 403   1          if(CY_PM_ENABLED == cyPmClockBackup.pllEnableState)
 404   1          {
 405   2              /***********************************************************************
 406   2              * Enable PLL. The actual CyPLL_OUT_Start() without wait period uses FTW
 407   2              * for period measurement. This could cause a problem if CTW/FTW is used
 408   2              * as a wakeup time in the low power modes APIs. To omit this issue PLL
 409   2              * wait procedure is implemented with a software delay.
 410   2              ***********************************************************************/
 411   2              status = CYRET_TIMEOUT;
 412   2      
 413   2              /* Enable PLL */
 414   2              (void) CyPLL_OUT_Start(CY_PM_PLL_OUT_NO_WAIT);
 415   2      
 416   2              /* Read to clear lock status after delay */
 417   2              CyDelayUs((uint32)80u);
 418   2              (void) CY_PM_FASTCLK_PLL_SR_REG;
 419   2      
 420   2              /* It should take 250 us lock: 251-80 = 171 */
 421   2              for(i = 171u; i > 0u; i--)
 422   2              {
 423   3                  CyDelayUs((uint32)1u);
 424   3      
C51 COMPILER V9.51   CYPM                                                                  03/16/2018 17:06:28 PAGE 8   

 425   3                  /* Accept PLL is OK after two consecutive polls indicate PLL lock */
 426   3                  if((0u != (CY_PM_FASTCLK_PLL_SR_REG & CY_PM_FASTCLK_PLL_LOCKED)) &&
 427   3                     (0u != (CY_PM_FASTCLK_PLL_SR_REG & CY_PM_FASTCLK_PLL_LOCKED)))
 428   3                  {
 429   4                      status = CYRET_SUCCESS;
 430   4                      break;
 431   4                  }
 432   3              }
 433   2      
 434   2              if(CYRET_TIMEOUT == status)
 435   2              {
 436   3                  /*******************************************************************
 437   3                  * Process the situation when PLL is not ready.
 438   3                  *******************************************************************/
 439   3                 /* `#START_PLL_TIMEOUT` */
 440   3      
 441   3                 /* `#END` */
 442   3      
 443   3              #ifdef CY_BOOT_CY_PM_RESTORE_CLOCKS_PLL_TIMEOUT_CALLBACK
                          CyBoot_CyPmRestoreClocks_PllTimeout_Callback();
                      #endif /* CY_BOOT_CY_PM_RESTORE_CLOCKS_PLL_TIMEOUT_CALLBACK */
 446   3              }
 447   2          }   /* (CY_PM_ENABLED == cyPmClockBackup.pllEnableState) */
 448   1      
 449   1      
 450   1          /* PLL and IMO is ready to be source for Master clock */
 451   1          if((CY_PM_MASTER_CLK_SRC_IMO == cyPmClockBackup.masterClkSrc) ||
 452   1             (CY_PM_MASTER_CLK_SRC_PLL == cyPmClockBackup.masterClkSrc))
 453   1          {
 454   2              /* Restore Master clock divider */
 455   2              if(CY_PM_CLKDIST_MSTR0_REG != cyPmClockBackup.clkSyncDiv)
 456   2              {
 457   3                  CyMasterClk_SetDivider(cyPmClockBackup.clkSyncDiv);
 458   3              }
 459   2      
 460   2              /* Restore Master clock source */
 461   2              CyMasterClk_SetSource(cyPmClockBackup.masterClkSrc);
 462   2          }
 463   1      
 464   1          /* IMO - disable if it was originally disabled */
 465   1          if((CY_PM_DISABLED == cyPmClockBackup.imoEnable) &&
 466   1             (0u != (CY_PM_ACT_CFG0_IMO & CY_PM_ACT_CFG0_REG)))
 467   1          {
 468   2              CyIMO_Stop();
 469   2          }
 470   1      
 471   1          /* Bus clock - restore divider, if needed */
 472   1          clkBusDivTmp = (uint16) ((uint16)CY_PM_CLK_BUS_MSB_DIV_REG << 8u);
 473   1          clkBusDivTmp |= CY_PM_CLK_BUS_LSB_DIV_REG;
 474   1          if(cyPmClockBackup.clkBusDiv != clkBusDivTmp)
 475   1          {
 476   2              CyBusClk_SetDivider(cyPmClockBackup.clkBusDiv);
 477   2          }
 478   1      
 479   1          /* Restore flash wait cycles */
 480   1          CY_PM_CACHE_CR_REG = ((CY_PM_CACHE_CR_REG & ((uint8)(~CY_PM_CACHE_CR_CYCLES_MASK))) |
 481   1                                 cyPmClockBackup.flashWaitCycles);
 482   1      
 483   1          /* Digital and analog clocks - restore state */
 484   1          CY_PM_ACT_CFG1_REG = cyPmClockBackup.enClkA;
 485   1          CY_PM_ACT_CFG2_REG = cyPmClockBackup.enClkD;
 486   1      }
C51 COMPILER V9.51   CYPM                                                                  03/16/2018 17:06:28 PAGE 9   

 487          
 488          
 489          /*******************************************************************************
 490          * Function Name: CyPmAltAct
 491          ****************************************************************************//**
 492          *
 493          *  Puts the part into the Alternate Active (Standby) state. The Alternate Active
 494          *  state can allow for any of the capabilities of the device to be active, but
 495          *  the operation of this function is dependent on the CPU being disabled during
 496          *  the Alternate Active state. The configuration code and the component APIs
 497          *  will configure the template for the Alternate Active state to be the same as
 498          *  the Active state with the exception that the CPU will be disabled during
 499          *  Alternate Active.
 500          *
 501          *  Note Before calling this function, you must manually configure the power mode
 502          *  of the source clocks for the timer that is used as the wakeup timer.
 503          *
 504          *  PSoC 3:
 505          *  Before switching to Alternate Active, if a wakeupTime other than NONE is
 506          *  specified, then the appropriate timer state is configured as specified with
 507          *  the interrupt for that timer disabled.  The wakeup source will be the
 508          *  combination of the values specified in the wakeupSource and any timer
 509          *  specified in the wakeupTime argument.  Once the wakeup condition is
 510          *  satisfied, then all saved state is restored and the function returns in the
 511          *  Active state.
 512          *
 513          *  Note that if the wakeupTime is made with a different value, the period before
 514          *  the wakeup occurs can be significantly shorter than the specified time.  If
 515          *  the next call is made with the same wakeupTime value, then the wakeup will
 516          *  occur the specified period after the previous wakeup occurred.
 517          *
 518          *  If a wakeupTime other than NONE is specified, then upon exit the state of the
 519          *  specified timer will be left as specified by wakeupTime with the timer
 520          *  enabled and the interrupt disabled.  If the CTW, FTW or One PPS is already
 521          *  configured for wakeup, for example with the SleepTimer or RTC components,
 522          *  then specify NONE for the wakeupTime and include the appropriate source for
 523          *  wakeupSource.
 524          *
 525          *  PSoC 5LP:
 526          *  This function is used to both enter the Alternate Active mode and halt the
 527          *  processor.  For PSoC 3 these two actions must be paired together.  With PSoC
 528          *  5LP the processor can be halted independently with the __WFI() function from
 529          *  the CMSIS library that is included in Creator.  This function should be used
 530          *  instead when the action required is just to halt the processor until an
 531          *  enabled interrupt occurs.
 532          *
 533          *  The wakeupTime parameter is not used for this device. It must be set to zero
 534          *  (PM_ALT_ACT_TIME_NONE). The wake up time configuration can be done by a
 535          *  separate component: the CTW wakeup interval should be configured with the
 536          *  Sleep Timer component and one second interval should be configured with the
 537          *  RTC component.
 538          *
 539          *  The wakeup behavior depends on the wakeupSource parameter in the following
 540          *  manner: upon function execution the device will be switched from Active to
 541          *  Alternate Active mode and then the CPU will be halted. When an enabled wakeup
 542          *  event occurs the device will return to Active mode.  Similarly when an
 543          *  enabled interrupt occurs the CPU will be started. These two actions will
 544          *  occur together provided that the event that occurs is an enabled wakeup
 545          *  source and also generates an interrupt. If just the wakeup event occurs then
 546          *  the device will be in Active mode, but the CPU will remain halted waiting for
 547          *  an interrupt. If an interrupt occurs from something other than a wakeup
 548          *  source, then the CPU will restart with the device in Alternate Active mode
C51 COMPILER V9.51   CYPM                                                                  03/16/2018 17:06:28 PAGE 10  

 549          *  until a wakeup event occurs.
 550          *
 551          *  For example, if CyPmAltAct(PM_ALT_ACT_TIME_NONE, PM_ALT_ACT_SRC_PICU) is
 552          *  called and PICU interrupt occurs, the CPU will be started and device will be
 553          *  switched into Active mode. And if CyPmAltAct(PM_ALT_ACT_TIME_NONE,
 554          *  PM_ALT_ACT_SRC_NONE) is called and PICU interrupt occurs, the CPU will be
 555          *  started while device remains in Alternate Active mode.
 556          *
 557          *  \param wakeupTime: Specifies a timer wakeup source and the frequency of that
 558          *              source. For PSoC 5LP this parameter is ignored.
 559          *
 560          *           Define                      Time
 561          *  PM_ALT_ACT_TIME_NONE             None
 562          *  \param PM_ALT_ACT_TIME_ONE_PPS          One PPS: 1 second
 563          *  \param PM_ALT_ACT_TIME_CTW_2MS          CTW: 2 ms
 564          *  \param PM_ALT_ACT_TIME_CTW_4MS          CTW: 4 ms
 565          *  \param PM_ALT_ACT_TIME_CTW_8MS          CTW: 8 ms
 566          *  \param PM_ALT_ACT_TIME_CTW_16MS         CTW: 16 ms
 567          *  \param PM_ALT_ACT_TIME_CTW_32MS         CTW: 32 ms
 568          *  \param PM_ALT_ACT_TIME_CTW_64MS         CTW: 64 ms
 569          *  \param PM_ALT_ACT_TIME_CTW_128MS        CTW: 128 ms
 570          *  \param PM_ALT_ACT_TIME_CTW_256MS        CTW: 256 ms
 571          *  \param PM_ALT_ACT_TIME_CTW_512MS        CTW: 512 ms
 572          *  \param PM_ALT_ACT_TIME_CTW_1024MS       CTW: 1024 ms
 573          *  \param PM_ALT_ACT_TIME_CTW_2048MS       CTW: 2048 ms
 574          *  \param PM_ALT_ACT_TIME_CTW_4096MS       CTW: 4096 ms
 575          *  PM_ALT_ACT_TIME_FTW(1-256)*       FTW: 10us to 2.56 ms
 576          *
 577          *  \param *Note:   PM_ALT_ACT_TIME_FTW() is a macro that takes an argument that
 578          *           specifies how many increments of 10 us to delay.
 579                      For PSoC 3 silicon the valid range of  values is 1 to 256.
 580          *
 581          *  \param wakeUpSource:    Specifies a bitwise mask of wakeup sources. In addition, if
 582          *                   a wakeupTime has been specified, the associated timer will
 583          *                   be included as a wakeup source.
 584          *
 585          *           Define                      Source
 586          *  PM_ALT_ACT_SRC_NONE              None
 587          *  PM_ALT_ACT_SRC_COMPARATOR0       Comparator 0
 588          *  PM_ALT_ACT_SRC_COMPARATOR1       Comparator 1
 589          *  PM_ALT_ACT_SRC_COMPARATOR2       Comparator 2
 590          *  PM_ALT_ACT_SRC_COMPARATOR3       Comparator 3
 591          *  PM_ALT_ACT_SRC_INTERRUPT         Interrupt
 592          *  PM_ALT_ACT_SRC_PICU              PICU
 593          *  PM_ALT_ACT_SRC_I2C               I2C
 594          *  PM_ALT_ACT_SRC_BOOSTCONVERTER    Boost Converter
 595          *  PM_ALT_ACT_SRC_FTW               Fast Timewheel*
 596          *  PM_ALT_ACT_SRC_VD                High and Low Voltage Detection (HVI, LVI)*
 597          *  PM_ALT_ACT_SRC_CTW               Central Timewheel**
 598          *  PM_ALT_ACT_SRC_ONE_PPS           One PPS**
 599          *  PM_ALT_ACT_SRC_LCD               LCD
 600          *
 601          *  \param *Note : FTW and HVI/LVI wakeup signals are in the same mask bit.
 602          *  \param **Note: CTW and One PPS wakeup signals are in the same mask bit.
 603          *
 604          *  When specifying a Comparator as the wakeupSource, an instance specific define
 605          *  that will track with the specific comparator that the instance
 606          *  is placed into should be used. As an example, for a Comparator instance named
 607          *  \param MyComp the value to OR into the mask is: MyComp_ctComp__CMP_MASK.
 608          *
 609          *  When CTW, FTW or One PPS is used as a wakeup source, the CyPmReadStatus()
 610          *  function must be called upon wakeup with a corresponding parameter. Please
C51 COMPILER V9.51   CYPM                                                                  03/16/2018 17:06:28 PAGE 11  

 611          *  refer to the CyPmReadStatus() API in the System Reference Guide for more
 612          *  information.
 613          *
 614          * Reentrant:
 615          *  No
 616          *
 617          * \sideeffect
 618          *  If a wakeupTime other than NONE is specified, then upon exit the state of the
 619          *  specified timer will be left as specified by wakeupTime with the timer
 620          *  enabled and the interrupt disabled.  Also, the ILO 1 KHz (if CTW timer is
 621          *  used as wakeup time) or ILO 100 KHz (if the FTW timer is used as wakeup time)
 622          *  will be left started.
 623          *
 624          *******************************************************************************/
 625          void CyPmAltAct(uint16 wakeupTime, uint16 wakeupSource) 
 626          {
 627   1          #if(CY_PSOC5)
              
                      /* Arguments expected to be 0 */
                      CYASSERT(PM_ALT_ACT_TIME_NONE == wakeupTime);
              
                      if(0u != wakeupTime)
                      {
                          /* To remove unreferenced local variable warning */
                      }
              
                  #endif /* (CY_PSOC5) */
 638   1      
 639   1      
 640   1          #if(CY_PSOC3)
 641   1      
 642   1              /* FTW - save current and set new configuration */
 643   1              if((wakeupTime >= PM_ALT_ACT_TIME_FTW(1u)) && (wakeupTime <= PM_ALT_ACT_TIME_FTW(256u)))
 644   1              {
 645   2                  CyPmFtwSetInterval(PM_ALT_ACT_FTW_INTERVAL(wakeupTime));
 646   2      
 647   2                  /* Include associated timer to wakeupSource */
 648   2                  wakeupSource |= PM_ALT_ACT_SRC_FTW;
 649   2              }
 650   1      
 651   1              /* CTW - save current and set new configuration */
 652   1              if((wakeupTime >= PM_ALT_ACT_TIME_CTW_2MS) && (wakeupTime <= PM_ALT_ACT_TIME_CTW_4096MS))
 653   1              {
 654   2                  /* Save current CTW configuration and set new one */
 655   2                  CyPmCtwSetInterval((uint8)(wakeupTime - 1u));
 656   2      
 657   2                  /* Include associated timer to wakeupSource */
 658   2                  wakeupSource |= PM_ALT_ACT_SRC_CTW;
 659   2              }
 660   1      
 661   1              /* 1PPS - save current and set new configuration */
 662   1              if(PM_ALT_ACT_TIME_ONE_PPS == wakeupTime)
 663   1              {
 664   2                  /* Save current 1PPS configuration and set new one */
 665   2                  CyPmOppsSet();
 666   2      
 667   2                  /* Include associated timer to wakeupSource */
 668   2                  wakeupSource |= PM_ALT_ACT_SRC_ONE_PPS;
 669   2              }
 670   1      
 671   1          #endif /* (CY_PSOC3) */
 672   1      
C51 COMPILER V9.51   CYPM                                                                  03/16/2018 17:06:28 PAGE 12  

 673   1      
 674   1          /* Save and set new wake up configuration */
 675   1      
 676   1          /* Interrupt, PICU, I2C, Boost converter, CTW/1PPS */
 677   1          cyPmBackup.wakeupCfg0 = CY_PM_WAKEUP_CFG0_REG;
 678   1          CY_PM_WAKEUP_CFG0_REG = (uint8) (wakeupSource >> 4u);
 679   1      
 680   1          /* Comparators */
 681   1          cyPmBackup.wakeupCfg1 = CY_PM_WAKEUP_CFG1_REG;
 682   1          CY_PM_WAKEUP_CFG1_REG = (((uint8) wakeupSource) & CY_PM_WAKEUP_SRC_CMPS_MASK);
 683   1      
 684   1          /* LCD */
 685   1          cyPmBackup.wakeupCfg2 = CY_PM_WAKEUP_CFG2_REG;
 686   1          CY_PM_WAKEUP_CFG2_REG = ((uint8) ((wakeupSource >> 12u) & 0x01u));
 687   1      
 688   1      
 689   1          /* Switch to the Alternate Active mode */
 690   1          CY_PM_MODE_CSR_REG = ((CY_PM_MODE_CSR_REG & ((uint8)(~CY_PM_MODE_CSR_MASK))) | CY_PM_MODE_CSR_ALT_ACT)
             -;
 691   1      
 692   1          /* Recommended readback. */
 693   1          (void) CY_PM_MODE_CSR_REG;
 694   1      
 695   1          /* Two recommended NOPs to get into the mode. */
 696   1          CY_NOP;
 697   1          CY_NOP;
 698   1      
 699   1          /* Execute WFI instruction (for ARM-based devices only) */
 700   1          CY_PM_WFI;
 701   1      
 702   1          /* Point of return from Alternate Active Mode */
 703   1      
 704   1          /* Restore wake up configuration */
 705   1          CY_PM_WAKEUP_CFG0_REG = cyPmBackup.wakeupCfg0;
 706   1          CY_PM_WAKEUP_CFG1_REG = cyPmBackup.wakeupCfg1;
 707   1          CY_PM_WAKEUP_CFG2_REG = cyPmBackup.wakeupCfg2;
 708   1      }
 709          
 710          
 711          /*******************************************************************************
 712          * Function Name: CyPmSleep
 713          ****************************************************************************//**
 714          *
 715          *  Puts the part into the Sleep state.
 716          *
 717          *  Note Before calling this function, you must manually configure the power
 718          *  mode of the source clocks for the timer that is used as the wakeup timer.
 719          *
 720          *  Note Before calling this function, you must prepare clock tree configuration
 721          *  for the low power mode by calling CyPmSaveClocks(). And restore clock
 722          *  configuration after CyPmSleep() execution by calling CyPmRestoreClocks(). See
 723          *  Power Management section, Clock Configuration subsection of the System
 724          *  Reference Guide for more information.
 725          *
 726          *  PSoC 3:
 727          *  Before switching to Sleep, if a wakeupTime other than NONE is specified,
 728          *  then the appropriate timer state is configured as specified with the
 729          *  interrupt for that timer disabled.  The wakeup source will be a combination
 730          *  of the values specified in the wakeupSource and any timer specified in the
 731          *  wakeupTime argument.  Once the wakeup condition is satisfied, then all saved
 732          *  state is restored and the function returns in the Active state.
 733          *
C51 COMPILER V9.51   CYPM                                                                  03/16/2018 17:06:28 PAGE 13  

 734          *  Note that if the wakeupTime is made with a different value, the period before
 735          *  the wakeup occurs can be significantly shorter than the specified time.  If
 736          *  the next call is made with the same wakeupTime value, then the wakeup will
 737          *  occur the specified period after the previous wakeup occurred.
 738          *
 739          *  If a wakeupTime other than NONE is specified, then upon exit the state of the
 740          *  specified timer will be left as specified by wakeupTime with the timer
 741          *  enabled and the interrupt disabled.  If the CTW or One PPS is already
 742          *  configured for wakeup, for example with the SleepTimer or RTC components,
 743          *  then specify NONE for the wakeupTime and include the appropriate source for
 744          *  wakeupSource.
 745          *
 746          *  PSoC 5LP:
 747          *  The wakeupTime parameter is not used and the only NONE can be specified.
 748          *  The wakeup time must be configured with the component, SleepTimer for CTW
 749          *  intervals and RTC for 1PPS interval. The component must be configured to
 750          *  generate interrupt.
 751          *
 752          *  \param wakeupTime:      Specifies a timer wakeup source and the frequency of that
 753          *                   source. For PSoC 5LP, this parameter is ignored.
 754          *
 755          *           Define                      Time
 756          *  PM_SLEEP_TIME_NONE               None
 757          *  \param PM_SLEEP_TIME_ONE_PPS            One PPS: 1 second
 758          *  \param PM_SLEEP_TIME_CTW_2MS            CTW: 2 ms
 759          *  \param PM_SLEEP_TIME_CTW_4MS            CTW: 4 ms
 760          *  \param PM_SLEEP_TIME_CTW_8MS            CTW: 8 ms
 761          *  \param PM_SLEEP_TIME_CTW_16MS           CTW: 16 ms
 762          *  \param PM_SLEEP_TIME_CTW_32MS           CTW: 32 ms
 763          *  \param PM_SLEEP_TIME_CTW_64MS           CTW: 64 ms
 764          *  \param PM_SLEEP_TIME_CTW_128MS          CTW: 128 ms
 765          *  \param PM_SLEEP_TIME_CTW_256MS          CTW: 256 ms
 766          *  \param PM_SLEEP_TIME_CTW_512MS          CTW: 512 ms
 767          *  \param PM_SLEEP_TIME_CTW_1024MS         CTW: 1024 ms
 768          *  \param PM_SLEEP_TIME_CTW_2048MS         CTW: 2048 ms
 769          *  \param PM_SLEEP_TIME_CTW_4096MS         CTW: 4096 ms
 770          *
 771          *  \param wakeUpSource:    Specifies a bitwise mask of wakeup sources. In addition, if
 772          *                   a wakeupTime has been specified the associated timer will be
 773          *                   included as a wakeup source.
 774          *
 775          *           Define                      Source
 776          *  PM_SLEEP_SRC_NONE                None
 777          *  PM_SLEEP_SRC_COMPARATOR0         Comparator 0
 778          *  PM_SLEEP_SRC_COMPARATOR1         Comparator 1
 779          *  PM_SLEEP_SRC_COMPARATOR2         Comparator 2
 780          *  PM_SLEEP_SRC_COMPARATOR3         Comparator 3
 781          *  PM_SLEEP_SRC_PICU                PICU
 782          *  PM_SLEEP_SRC_I2C                 I2C
 783          *  PM_SLEEP_SRC_BOOSTCONVERTER      Boost Converter
 784          *  PM_SLEEP_SRC_VD                  High and Low Voltage Detection (HVI, LVI)
 785          *  PM_SLEEP_SRC_CTW                 Central Timewheel*
 786          *  PM_SLEEP_SRC_ONE_PPS             One PPS*
 787          *  PM_SLEEP_SRC_LCD                 LCD
 788          *
 789          *  \param *Note:   CTW and One PPS wakeup signals are in the same mask bit.
 790          *
 791          *  When specifying a Comparator as the wakeupSource an instance specific define
 792          *  should be used that will track with the specific comparator that the instance
 793          *  is placed into. As an example for a Comparator instance named MyComp the
 794          *  \param value to OR into the mask is: MyComp_ctComp__CMP_MASK.
 795          *
C51 COMPILER V9.51   CYPM                                                                  03/16/2018 17:06:28 PAGE 14  

 796          *  When CTW or One PPS is used as a wakeup source, the CyPmReadStatus()
 797          *  function must be called upon wakeup with corresponding parameter. Please
 798          *  refer to the CyPmReadStatus() API in the System Reference Guide for more
 799          *  information.
 800          *
 801          * Reentrant:
 802          *  No
 803          *
 804          * Side Effects and Restrictions:
 805          *  If a wakeupTime other than NONE is specified, then upon exit the state of the
 806          *  specified timer will be left as specified by wakeupTime with the timer
 807          *  enabled and the interrupt disabled. Also, the ILO 1 KHz (if CTW timer is
 808          *  used as wake up time) will be left started.
 809          *
 810          *  The 1 kHz ILO clock is expected to be enabled for PSoC 3 and PSoC 5LP to
 811          *  measure Hibernate/Sleep regulator settling time after a reset. The holdoff
 812          *  delay is measured using rising edges of the 1 kHz ILO.
 813          *
 814          *  For PSoC 3 silicon hardware buzz should be disabled before entering a sleep
 815          *  power mode. It is disabled by PSoC Creator during startup.
 816          *  If a Low Voltage Interrupt (LVI), High Voltage Interrupt (HVI) or Brown Out
 817          *  detect (power supply supervising capabilities) are required in a design
 818          *  during sleep, use the Central Time Wheel (CTW) to periodically wake the
 819          *  device, perform software buzz, and refresh the supervisory services. If LVI,
 820          *  HVI, or Brown Out is not required, then CTW is not required.
 821          *  Refer to the device errata for more information.
 822          *
 823          *******************************************************************************/
 824          void CyPmSleep(uint8 wakeupTime, uint16 wakeupSource) 
 825          {
 826   1          uint8 interruptState;
 827   1      
 828   1          /* Save current global interrupt enable and disable it */
 829   1          interruptState = CyEnterCriticalSection();
 830   1      
 831   1      
 832   1          /***********************************************************************
 833   1          * The Hibernate/Sleep regulator has a settling time after a reset.
 834   1          * During this time, the system ignores requests to enter Sleep and
 835   1          * Hibernate modes. The holdoff delay is measured using rising edges of
 836   1          * the 1 kHz ILO.
 837   1          ***********************************************************************/
 838   1          if(0u == (CY_PM_MODE_CSR_REG & CY_PM_MODE_CSR_PWRUP_PULSE_Q))
 839   1          {
 840   2              /* Disable hold off - no action on restore */
 841   2              CY_PM_PWRSYS_SLP_TR_REG &= CY_PM_PWRSYS_SLP_TR_HIBSLP_HOLDOFF_MASK;
 842   2          }
 843   1          else
 844   1          {
 845   2              /* Abort, device is not ready for low power mode entry */
 846   2      
 847   2              /* Restore global interrupt enable state */
 848   2              CyExitCriticalSection(interruptState);
 849   2      
 850   2              return;
 851   2          }
 852   1      
 853   1      
 854   1          /***********************************************************************
 855   1          * PSoC3 < TO6:
 856   1          * - Hardware buzz must be disabled before the sleep mode entry.
 857   1          * - Voltage supervision (HVI/LVI) requires hardware buzz, so they must
C51 COMPILER V9.51   CYPM                                                                  03/16/2018 17:06:28 PAGE 15  

 858   1          *   be also disabled.
 859   1          *
 860   1          * PSoC3 >= TO6:
 861   1          * - Voltage supervision (HVI/LVI) requires hardware buzz, so hardware
 862   1          *   buzz must be enabled before the sleep mode entry and restored on
 863   1          *   the wakeup.
 864   1          ***********************************************************************/
 865   1          #if(CY_PSOC3)
 866   1      
 867   1              /* Silicon Revision ID is below TO6 */
 868   1              if(CYDEV_CHIP_REV_ACTUAL < 5u)
 869   1              {
 870   2                  /* Hardware buzz expected to be disabled in Sleep mode */
 871   2                  CYASSERT(0u == (CY_PM_PWRSYS_WAKE_TR2_REG & CY_PM_PWRSYS_WAKE_TR2_EN_BUZZ));
 872   2              }
 873   1      
 874   1      
 875   1              if(0u != (CY_PM_RESET_CR1_REG & (CY_PM_RESET_CR1_HVIA_EN |
 876   1                  CY_PM_RESET_CR1_LVIA_EN | CY_PM_RESET_CR1_LVID_EN)))
 877   1              {
 878   2                  if(CYDEV_CHIP_REV_ACTUAL < 5u)
 879   2                  {
 880   3                      /* LVI/HVI requires hardware buzz to be enabled */
 881   3                      CYASSERT(0u != 0u);
 882   3                  }
 883   2                  else
 884   2                  {
 885   3                      if (0u == (CY_PM_PWRSYS_WAKE_TR2_REG & CY_PM_PWRSYS_WAKE_TR2_EN_BUZZ))
 886   3                      {
 887   4                          cyPmBackup.hardwareBuzz = CY_PM_DISABLED;
 888   4                          CY_PM_PWRSYS_WAKE_TR2_REG |= CY_PM_PWRSYS_WAKE_TR2_EN_BUZZ;
 889   4                      }
 890   3                      else
 891   3                      {
 892   4                          cyPmBackup.hardwareBuzz = CY_PM_ENABLED;
 893   4                      }
 894   3                  }
 895   2              }
 896   1      
 897   1          #endif /* (CY_PSOC3) */
 898   1      
 899   1      
 900   1          /*******************************************************************************
 901   1          * For ARM-based devices,interrupt is required for the CPU to wake up. The
 902   1          * Power Management implementation assumes that wakeup time is configured with a
 903   1          * separate component (component-based wakeup time configuration) for
 904   1          * interrupt to be issued on terminal count. For more information, refer to the
 905   1          * Wakeup Time Configuration section of System Reference Guide.
 906   1          *******************************************************************************/
 907   1          #if(CY_PSOC5)
              
                      /* Arguments expected to be 0 */
                      CYASSERT(PM_SLEEP_TIME_NONE == wakeupTime);
              
                      if(0u != wakeupTime)
                      {
                          /* To remove unreferenced local variable warning */
                      }
              
                  #endif /* (CY_PSOC5) */
 918   1      
 919   1      
C51 COMPILER V9.51   CYPM                                                                  03/16/2018 17:06:28 PAGE 16  

 920   1          CyPmHibSlpSaveSet();
 921   1      
 922   1      
 923   1          #if(CY_PSOC3)
 924   1      
 925   1              /* CTW - save current and set new configuration */
 926   1              if((wakeupTime >= PM_SLEEP_TIME_CTW_2MS) && (wakeupTime <= PM_SLEEP_TIME_CTW_4096MS))
 927   1              {
 928   2                  /* Save current and set new configuration of CTW */
 929   2                  CyPmCtwSetInterval((uint8)(wakeupTime - 1u));
 930   2      
 931   2                  /* Include associated timer to wakeupSource */
 932   2                  wakeupSource |= PM_SLEEP_SRC_CTW;
 933   2              }
 934   1      
 935   1              /* 1PPS - save current and set new configuration */
 936   1              if(PM_SLEEP_TIME_ONE_PPS == wakeupTime)
 937   1              {
 938   2                  /* Save current and set new configuration of the 1PPS */
 939   2                  CyPmOppsSet();
 940   2      
 941   2                  /* Include associated timer to wakeupSource */
 942   2                  wakeupSource |= PM_SLEEP_SRC_ONE_PPS;
 943   2              }
 944   1      
 945   1          #endif /* (CY_PSOC3) */
 946   1      
 947   1      
 948   1          /* Save and set new wake up configuration */
 949   1      
 950   1          /* Interrupt, PICU, I2C, Boost converter, CTW/1PPS */
 951   1          cyPmBackup.wakeupCfg0 = CY_PM_WAKEUP_CFG0_REG;
 952   1          CY_PM_WAKEUP_CFG0_REG = (uint8) (wakeupSource >> 4u);
 953   1      
 954   1          /* Comparators */
 955   1          cyPmBackup.wakeupCfg1 = CY_PM_WAKEUP_CFG1_REG;
 956   1          CY_PM_WAKEUP_CFG1_REG = (((uint8) wakeupSource) & CY_PM_WAKEUP_SRC_CMPS_MASK);
 957   1      
 958   1          /* LCD */
 959   1          cyPmBackup.wakeupCfg2 = CY_PM_WAKEUP_CFG2_REG;
 960   1          CY_PM_WAKEUP_CFG2_REG = ((uint8) ((wakeupSource >> 12u) & 0x01u));
 961   1      
 962   1      
 963   1          /*******************************************************************
 964   1          * Do not use the merge region below unless any component datasheet
 965   1          * suggests doing so.
 966   1          *******************************************************************/
 967   1          /* `#START CY_PM_JUST_BEFORE_SLEEP` */
 968   1      
 969   1          /* `#END` */
 970   1      
 971   1          #ifdef CY_BOOT_CY_PM_SLEEP_BEFORE_SLEEP_CALLBACK
                      CyBoot_CyPmSleep_BeforeSleep_Callback();
                  #endif /* CY_BOOT_CY_PM_SLEEP_BEFORE_SLEEP_CALLBACK */
 974   1      
 975   1          /* Last moment IMO frequency change */
 976   1          if(0u == (CY_PM_FASTCLK_IMO_CR_REG & CY_PM_FASTCLK_IMO_CR_FREQ_MASK))
 977   1          {
 978   2              /* IMO frequency is 12 MHz */
 979   2              cyPmBackup.imoActFreq12Mhz = CY_PM_ENABLED;
 980   2          }
 981   1          else
C51 COMPILER V9.51   CYPM                                                                  03/16/2018 17:06:28 PAGE 17  

 982   1          {
 983   2              /* IMO frequency is not 12 MHz */
 984   2              cyPmBackup.imoActFreq12Mhz = CY_PM_DISABLED;
 985   2      
 986   2              /* Save IMO frequency */
 987   2              cyPmBackup.imoActFreq = CY_PM_FASTCLK_IMO_CR_REG & CY_PM_FASTCLK_IMO_CR_FREQ_MASK;
 988   2      
 989   2              /* Set IMO frequency to 12 MHz */
 990   2              CY_PM_FASTCLK_IMO_CR_REG &= ((uint8) (~CY_PM_FASTCLK_IMO_CR_FREQ_MASK));
 991   2          }
 992   1      
 993   1          /* Switch to Sleep mode */
 994   1          CY_PM_MODE_CSR_REG = ((CY_PM_MODE_CSR_REG & ((uint8)(~CY_PM_MODE_CSR_MASK))) | CY_PM_MODE_CSR_SLEEP);
 995   1      
 996   1          /* Recommended readback. */
 997   1          (void) CY_PM_MODE_CSR_REG;
 998   1      
 999   1          /* Two recommended NOPs to get into mode. */
1000   1          CY_NOP;
1001   1          CY_NOP;
1002   1      
1003   1          /* Execute WFI instruction (for ARM-based devices only) */
1004   1          CY_PM_WFI;
1005   1      
1006   1          /* Point of return from Sleep Mode */
1007   1      
1008   1          /* Restore last moment IMO frequency change */
1009   1          if(CY_PM_ENABLED != cyPmBackup.imoActFreq12Mhz)
1010   1          {
1011   2              CY_PM_FASTCLK_IMO_CR_REG  = (CY_PM_FASTCLK_IMO_CR_REG & ((uint8)(~CY_PM_FASTCLK_IMO_CR_FREQ_MASK))
             -) |
1012   2                                          cyPmBackup.imoActFreq;
1013   2          }
1014   1      
1015   1      
1016   1          /*******************************************************************
1017   1          * Do not use merge region below unless any component datasheet
1018   1          * suggest to do so.
1019   1          *******************************************************************/
1020   1          /* `#START CY_PM_JUST_AFTER_WAKEUP_FROM_SLEEP` */
1021   1      
1022   1          /* `#END` */
1023   1      
1024   1          #ifdef CY_BOOT_CY_PM_SLEEP_AFTER_SLEEP_CALLBACK
                      CyBoot_CyPmSleep_AfterSleep_Callback();
                  #endif /* CY_BOOT_CY_PM_SLEEP_AFTER_SLEEP_CALLBACK */
1027   1      
1028   1          /* Restore hardware configuration */
1029   1          CyPmHibSlpRestore();
1030   1      
1031   1      
1032   1          /* Disable hardware buzz, if it was previously enabled */
1033   1          #if(CY_PSOC3)
1034   1      
1035   1              if(0u != (CY_PM_RESET_CR1_REG & (CY_PM_RESET_CR1_HVIA_EN |
1036   1                  CY_PM_RESET_CR1_LVIA_EN | CY_PM_RESET_CR1_LVID_EN)))
1037   1              {
1038   2                  if(CYDEV_CHIP_REV_ACTUAL >= 5u)
1039   2                  {
1040   3                      if (CY_PM_DISABLED == cyPmBackup.hardwareBuzz)
1041   3                      {
1042   4                          CY_PM_PWRSYS_WAKE_TR2_REG &= (uint8)(~CY_PM_PWRSYS_WAKE_TR2_EN_BUZZ);
C51 COMPILER V9.51   CYPM                                                                  03/16/2018 17:06:28 PAGE 18  

1043   4                      }
1044   3                  }
1045   2              }
1046   1      
1047   1          #endif /* (CY_PSOC3) */
1048   1      
1049   1      
1050   1          /* Restore current wake up configuration */
1051   1          CY_PM_WAKEUP_CFG0_REG = cyPmBackup.wakeupCfg0;
1052   1          CY_PM_WAKEUP_CFG1_REG = cyPmBackup.wakeupCfg1;
1053   1          CY_PM_WAKEUP_CFG2_REG = cyPmBackup.wakeupCfg2;
1054   1      
1055   1          /* Restore global interrupt enable state */
1056   1          CyExitCriticalSection(interruptState);
1057   1      }
1058          
1059          
1060          /*******************************************************************************
1061          * Function Name: CyPmHibernate
1062          ****************************************************************************//**
1063          *
1064          *  Puts the part into the Hibernate state.
1065          *
1066          *  Before switching to Hibernate, the current status of the PICU wakeup source
1067          *  bit is saved and then set. This configures the device to wake up from the
1068          *  PICU. Make sure you have at least one pin configured to generate PICU
1069          *  interrupt. For pin Px.y, the register "PICU_INTTYPE_PICUx_INTTYPEy" controls
1070          *  the PICU behavior. In the TRM, this register is "PICU[0..15]_INTTYPE[0..7]."
1071          *  In the Pins component datasheet, this register is referred to as the IRQ
1072          *  option. Once the wakeup occurs, the PICU wakeup source bit is restored and
1073          *  the PSoC returns to the Active state.
1074          *
1075          * Reentrant:
1076          *  No
1077          *
1078          * \sideeffect
1079          *  Applications must wait 20 us before re-entering hibernate or sleep after
1080          *  waking up from hibernate. The 20 us allows the sleep regulator time to
1081          *  stabilize before the next hibernate / sleep event occurs. The 20 us
1082          *  requirement begins when the device wakes up. There is no hardware check that
1083          *  this requirement is met. The specified delay should be done on ISR entry.
1084          *
1085          *  After the wakeup PICU interrupt occurs, the Pin_ClearInterrupt() (where Pin
1086          *  is instance name of the Pins component) function must be called to clear the
1087          *  latched pin events to allow the proper Hibernate mode entry and to enable
1088          *  detection of future events.
1089          *
1090          *  The 1 kHz ILO clock is expected to be enabled for PSoC 3 and PSoC 5LP to
1091          *  measure Hibernate/Sleep regulator settling time after a reset. The holdoff
1092          *  delay is measured using the rising edges of the 1 kHz ILO.
1093          *
1094          *******************************************************************************/
1095          void CyPmHibernate(void) 
1096          {
1097   1          CyPmHibernateEx(CY_PM_HIB_SRC_PICU);
1098   1      }
1099          
1100          
1101          /*******************************************************************************
1102          * Function Name: CyPmHibernateEx
1103          ****************************************************************************//**
1104          *
C51 COMPILER V9.51   CYPM                                                                  03/16/2018 17:06:28 PAGE 19  

1105          *  Puts the part into the Hibernate state.
1106          *
1107          *  The following wake up sources can be configured: PICU interrupt, Comparator0,
1108          *  Comparator1, Comparator2, and Comparator3 output.
1109          *
1110          *  Before switching to Hibernate, the current status of the PICU wakeup source
1111          *  bit is saved and then set.
1112          *
1113          *  If using PICU as the wake up source, make sure you have at least one pin
1114          *  configured to generate a PICU interrupt. For pin Px.y, the register
1115          *  "PICU_INTTYPE_PICUx_INTTYPEy" controls  the PICU behavior. In the TRM, this
1116          *  register is "PICU[0..15]_INTTYPE[0..7]." In the Pins component datasheet,
1117          *  this register is referred to as the IRQ option. Once the wakeup occurs, the
1118          *  PICU wakeup source bit is restored and the PSoC returns to the Active state.
1119          *
1120          *  If using a comparator as the wake up source, make sure you call this function
1121          *  with the 'wakeupSource' parameter set to the appropriate comparator. The part
1122          *  is configured for the requested wakeup source by setting the corresponding
1123          *  bits in PM_WAKEUP_CFG1 register.
1124          *
1125          *  Function call CyPmHibernateEx(CY_PM_HIB_SRC_PICU) will act in the same way as
1126          *  CyPmHibernate().
1127          *
1128          *  \param wakeupSource:
1129          *           Parameter Value             Description
1130          *       CY_PM_HIB_SRC_PICU          PICU interrupt is set as the wake up source.
1131          *       CY_PM_HIB_SRC_COMPARATOR0   Comparator 0 is set as the wake up source.
1132          *       CY_PM_HIB_SRC_COMPARATOR1   Comparator 1 is set as the wake up source.
1133          *       CY_PM_HIB_SRC_COMPARATOR2   Comparator 2 is set as the wake up source.
1134          *       CY_PM_HIB_SRC_COMPARATOR3   Comparator 3 is set as the wake up source.
1135          *
1136          * Reentrant:
1137          *  No
1138          *
1139          * \sideeffect
1140          *  Applications must wait 20 us before re-entering hibernate or sleep after
1141          *  waking up from hibernate. The 20 us allows the sleep regulator time to
1142          *  stabilize before the next hibernate / sleep event occurs. The 20 us
1143          *  requirement begins when the device wakes up. There is no hardware check that
1144          *  this requirement is met. The specified delay should be done on ISR entry.
1145          *
1146          *  After the wakeup PICU interrupt occurs, the Pin_ClearInterrupt() (where Pin
1147          *  is instance name of the Pins component) function must be called to clear the
1148          *  latched pin events to allow the proper Hibernate mode entry and to enable
1149          *  detection of future events.
1150          *
1151          *  The 1 kHz ILO clock is expected to be enabled for PSoC 3 and PSoC 5LP to
1152          *  measure Hibernate/Sleep regulator settling time after a reset. The holdoff
1153          *  delay is measured using the rising edges of the 1 kHz ILO.
1154          *
1155          *******************************************************************************/
1156          void CyPmHibernateEx(uint16 wakeupSource) 
1157          {
1158   1          uint8 interruptState;
1159   1      
1160   1          /* Save current global interrupt enable and disable it */
1161   1          interruptState = CyEnterCriticalSection();
1162   1      
1163   1              /***********************************************************************
1164   1              * The Hibernate/Sleep regulator has a settling time after a reset.
1165   1              * During this time, the system ignores requests to enter the Sleep and
1166   1              * Hibernate modes. The holdoff delay is measured using the rising edges of
C51 COMPILER V9.51   CYPM                                                                  03/16/2018 17:06:28 PAGE 20  

1167   1              * the 1 kHz ILO.
1168   1              ***********************************************************************/
1169   1              if(0u == (CY_PM_MODE_CSR_REG & CY_PM_MODE_CSR_PWRUP_PULSE_Q))
1170   1              {
1171   2                  /* Disable hold off - no action on restore */
1172   2                  CY_PM_PWRSYS_SLP_TR_REG &= CY_PM_PWRSYS_SLP_TR_HIBSLP_HOLDOFF_MASK;
1173   2              }
1174   1              else
1175   1              {
1176   2                  /* Abort, device is not ready for low power mode entry */
1177   2      
1178   2                  /* Restore global interrupt enable state */
1179   2                  CyExitCriticalSection(interruptState);
1180   2      
1181   2                  return;
1182   2              }
1183   1      
1184   1          CyPmHibSaveSet();
1185   1      
1186   1      
1187   1          /* Save and set new wake up configuration */
1188   1      
1189   1          /* Save and enable only wakeup on PICU */
1190   1          cyPmBackup.wakeupCfg0 = CY_PM_WAKEUP_CFG0_REG;
1191   1          CY_PM_WAKEUP_CFG0_REG = ((uint8) (wakeupSource >> 4u) & CY_PM_WAKEUP_PICU);
1192   1      
1193   1          /* Comparators */
1194   1          cyPmBackup.wakeupCfg1 = CY_PM_WAKEUP_CFG1_REG;
1195   1          CY_PM_WAKEUP_CFG1_REG = (((uint8) wakeupSource) & CY_PM_WAKEUP_SRC_CMPS_MASK);
1196   1      
1197   1          cyPmBackup.wakeupCfg2 = CY_PM_WAKEUP_CFG2_REG;
1198   1          CY_PM_WAKEUP_CFG2_REG = 0x00u;
1199   1      
1200   1      
1201   1          /* Last moment IMO frequency change */
1202   1          if(0u == (CY_PM_FASTCLK_IMO_CR_REG & CY_PM_FASTCLK_IMO_CR_FREQ_MASK))
1203   1          {
1204   2              /* IMO frequency is 12 MHz */
1205   2              cyPmBackup.imoActFreq12Mhz = CY_PM_ENABLED;
1206   2          }
1207   1          else
1208   1          {
1209   2              /* IMO frequency is not 12 MHz */
1210   2              cyPmBackup.imoActFreq12Mhz = CY_PM_DISABLED;
1211   2      
1212   2              /* Save IMO frequency */
1213   2              cyPmBackup.imoActFreq = CY_PM_FASTCLK_IMO_CR_REG & CY_PM_FASTCLK_IMO_CR_FREQ_MASK;
1214   2      
1215   2              /* Set IMO frequency to 12 MHz */
1216   2              CY_PM_FASTCLK_IMO_CR_REG &= ((uint8) (~CY_PM_FASTCLK_IMO_CR_FREQ_MASK));
1217   2          }
1218   1      
1219   1      
1220   1          /* Switch to Hibernate Mode */
1221   1          CY_PM_MODE_CSR_REG = (CY_PM_MODE_CSR_REG & ((uint8) (~CY_PM_MODE_CSR_MASK))) | CY_PM_MODE_CSR_HIBERNAT
             -E;
1222   1      
1223   1          /* Recommended readback. */
1224   1          (void) CY_PM_MODE_CSR_REG;
1225   1      
1226   1          /* Two recommended NOPs to get into mode. */
1227   1          CY_NOP;
C51 COMPILER V9.51   CYPM                                                                  03/16/2018 17:06:28 PAGE 21  

1228   1          CY_NOP;
1229   1      
1230   1          /* Execute WFI instruction (for ARM-based devices only) */
1231   1          CY_PM_WFI;
1232   1      
1233   1      
1234   1          /* Point of return from Hibernate mode */
1235   1      
1236   1      
1237   1          /* Restore last moment IMO frequency change */
1238   1          if(CY_PM_ENABLED != cyPmBackup.imoActFreq12Mhz)
1239   1          {
1240   2              CY_PM_FASTCLK_IMO_CR_REG  = (CY_PM_FASTCLK_IMO_CR_REG & ((uint8)(~CY_PM_FASTCLK_IMO_CR_FREQ_MASK))
             -) |
1241   2                                          cyPmBackup.imoActFreq;
1242   2          }
1243   1      
1244   1      
1245   1          /* Restore device for proper Hibernate mode exit*/
1246   1          CyPmHibRestore();
1247   1      
1248   1          /* Restore current wake up configuration */
1249   1          CY_PM_WAKEUP_CFG0_REG = cyPmBackup.wakeupCfg0;
1250   1          CY_PM_WAKEUP_CFG1_REG = cyPmBackup.wakeupCfg1;
1251   1          CY_PM_WAKEUP_CFG2_REG = cyPmBackup.wakeupCfg2;
1252   1      
1253   1          /* Restore global interrupt enable state */
1254   1          CyExitCriticalSection(interruptState);
1255   1      }
1256          
1257          
1258          /*******************************************************************************
1259          * Function Name: CyPmReadStatus
1260          ****************************************************************************//**
1261          *
1262          *  Manages the Power Manager Interrupt Status Register.  This register has the
1263          *  interrupt status for the one pulse per second, central timewheel and fast
1264          *  timewheel timers.  This hardware register clears on read.  To allow for only
1265          *  clearing the bits of interest and preserving the other bits, this function
1266          *  uses a shadow register that retains the state.  This function reads the
1267          *  status register and ORs that value with the shadow register.  That is the
1268          *  value that is returned.  Then the bits in the mask that are set are cleared
1269          *  from this value and written back to the shadow register.
1270          *
1271          *  Note You must call this function within 1 ms (1 clock cycle of the ILO)
1272          *  after a CTW event has occurred.
1273          *
1274          *  \param mask: Bits in the shadow register to clear.
1275          *
1276          *       Define                      Source
1277          *  CY_PM_FTW_INT                Fast Timewheel
1278          *  CY_PM_CTW_INT                Central Timewheel
1279          *  CY_PM_ONEPPS_INT             One Pulse Per Second
1280          *
1281          * \return
1282          *  Status.  Same bits values as the mask parameter.
1283          *
1284          *******************************************************************************/
1285          uint8 CyPmReadStatus(uint8 mask) 
1286          {
1287   1          static uint8 interruptStatus;
1288   1          uint8 interruptState;
C51 COMPILER V9.51   CYPM                                                                  03/16/2018 17:06:28 PAGE 22  

1289   1          uint8 tmpStatus;
1290   1      
1291   1          /* Enter critical section */
1292   1          interruptState = CyEnterCriticalSection();
1293   1      
1294   1          /* Save value of register, copy it and clear desired bit */
1295   1          interruptStatus |= CY_PM_INT_SR_REG;
1296   1          tmpStatus = interruptStatus & (CY_PM_FTW_INT | CY_PM_CTW_INT | CY_PM_ONEPPS_INT);
1297   1          interruptStatus &= ((uint8)(~mask));
1298   1      
1299   1          /* Exit critical section */
1300   1          CyExitCriticalSection(interruptState);
1301   1      
1302   1          return(tmpStatus);
1303   1      }
1304          
1305          
1306          /*******************************************************************************
1307          * Function Name: CyPmHibSaveSet
1308          ****************************************************************************//**
1309          *
1310          *  Prepare device for proper Hibernate low power mode entry:
1311          *  - Disables I2C backup regulator
1312          *  - Saves ILO power down mode state and enable it
1313          *  - Saves state of 1 kHz and 100 kHz ILO and disable them
1314          *  - Disables sleep regulator and shorts vccd to vpwrsleep
1315          *  - Save LVI/HVI configuration and disable them - CyPmHviLviSaveDisable()
1316          *  - CyPmHibSlpSaveSet() function is called
1317          *
1318          * Reentrant:
1319          *  No
1320          *
1321          *******************************************************************************/
1322          static void CyPmHibSaveSet(void) 
1323          {
1324   1          /* I2C backup reg must be off when the sleep regulator is unavailable */
1325   1          if(0u != (CY_PM_PWRSYS_CR1_REG & CY_PM_PWRSYS_CR1_I2CREG_BACKUP))
1326   1          {
1327   2              /***********************************************************************
1328   2              * If the I2C backup regulator is enabled, all the fixed-function registers
1329   2              * store their values while the device is in the low power mode, otherwise their
1330   2              * configuration is lost. The I2C API makes a decision to restore or not
1331   2              * to restore I2C registers based on this. If this regulator will be
1332   2              * disabled and then enabled, I2C API will suppose that the I2C block
1333   2              * registers preserved their values, while this is not true. So, the
1334   2              * backup regulator is disabled. The I2C sleep APIs is responsible for
1335   2              * restoration.
1336   2              ***********************************************************************/
1337   2      
1338   2              /* Disable I2C backup register */
1339   2              CY_PM_PWRSYS_CR1_REG &= ((uint8)(~CY_PM_PWRSYS_CR1_I2CREG_BACKUP));
1340   2          }
1341   1      
1342   1      
1343   1          /* Save current ILO power mode and ensure low power mode */
1344   1          cyPmBackup.iloPowerMode = CyILO_SetPowerMode(CY_PM_POWERDOWN_MODE);
1345   1      
1346   1          /* Save current 1kHz ILO enable state. Disabled automatically. */
1347   1          cyPmBackup.ilo1kEnable = (0u == (CY_PM_SLOWCLK_ILO_CR0_REG & CY_PM_ILO_CR0_EN_1K)) ?
1348   1                                      CY_PM_DISABLED : CY_PM_ENABLED;
1349   1      
1350   1          /* Save current 100kHz ILO enable state. Disabled automatically. */
C51 COMPILER V9.51   CYPM                                                                  03/16/2018 17:06:28 PAGE 23  

1351   1          cyPmBackup.ilo100kEnable = (0u == (CY_PM_SLOWCLK_ILO_CR0_REG & CY_PM_ILO_CR0_EN_100K)) ?
1352   1                                      CY_PM_DISABLED : CY_PM_ENABLED;
1353   1      
1354   1      
1355   1          /* Disable the sleep regulator and shorts vccd to vpwrsleep */
1356   1          if(0u == (CY_PM_PWRSYS_SLP_TR_REG & CY_PM_PWRSYS_SLP_TR_BYPASS))
1357   1          {
1358   2              /* Save current bypass state */
1359   2              cyPmBackup.slpTrBypass = CY_PM_DISABLED;
1360   2              CY_PM_PWRSYS_SLP_TR_REG |= CY_PM_PWRSYS_SLP_TR_BYPASS;
1361   2          }
1362   1          else
1363   1          {
1364   2              cyPmBackup.slpTrBypass = CY_PM_ENABLED;
1365   2          }
1366   1      
1367   1          /* LPCOMPs are always enabled (even when BOTH ext_vccd=1 and ext_vcca=1)*/
1368   1      
1369   1      
1370   1          /***************************************************************************
1371   1          * LVI/HVI must be disabled in Hibernate
1372   1          ***************************************************************************/
1373   1      
1374   1          /* Save LVI/HVI configuration and disable them */
1375   1          CyPmHviLviSaveDisable();
1376   1      
1377   1      
1378   1          /* Make the same preparations for Hibernate and Sleep modes */
1379   1          CyPmHibSlpSaveSet();
1380   1      
1381   1      
1382   1          /***************************************************************************
1383   1          * Save and set the power mode wakeup trim registers
1384   1          ***************************************************************************/
1385   1          cyPmBackup.wakeupTrim0 = CY_PM_PWRSYS_WAKE_TR0_REG;
1386   1          cyPmBackup.wakeupTrim1 = CY_PM_PWRSYS_WAKE_TR1_REG;
1387   1          
1388   1          #if(CY_PSOC5)
                      cyPmBackup.wakeupTrim3 = CY_PM_PWRSYS_WAKE_TR3_REG;
                  #endif  /* (CY_PSOC5) */    
1391   1      
1392   1          CY_PM_PWRSYS_WAKE_TR0_REG = CY_PM_PWRSYS_WAKE_TR0;
1393   1          CY_PM_PWRSYS_WAKE_TR1_REG = CY_PM_PWRSYS_WAKE_TR1;
1394   1          
1395   1          #if(CY_PSOC5)
                      CY_PM_PWRSYS_WAKE_TR3_REG = CY_PM_PWRSYS_WAKE_TR3;
                  #endif  /* (CY_PSOC5) */    
1398   1      }
1399          
1400          
1401          /*******************************************************************************
1402          * Function Name: CyPmHibRestore
1403          ****************************************************************************//**
1404          *
1405          *  Restores the device for the proper Hibernate mode exit:
1406          *  - Restores LVI/HVI configuration - calsl CyPmHviLviRestore()
1407          *  - CyPmHibSlpSaveRestore() function is called
1408          *  - Restores ILO power down mode state and enables it
1409          *  - Restores the state of 1 kHz and 100 kHz ILO and disables them
1410          *  - Restores the sleep regulator settings
1411          *
1412          *******************************************************************************/
C51 COMPILER V9.51   CYPM                                                                  03/16/2018 17:06:28 PAGE 24  

1413          static void CyPmHibRestore(void) 
1414          {
1415   1          /* Restore LVI/HVI configuration */
1416   1          CyPmHviLviRestore();
1417   1      
1418   1          /* Restore the same configuration for Hibernate and Sleep modes */
1419   1          CyPmHibSlpRestore();
1420   1      
1421   1          /* Restore 1kHz ILO enable state */
1422   1          if(CY_PM_ENABLED == cyPmBackup.ilo1kEnable)
1423   1          {
1424   2              /* Enable 1kHz ILO */
1425   2              CyILO_Start1K();
1426   2          }
1427   1      
1428   1          /* Restore 100kHz ILO enable state */
1429   1          if(CY_PM_ENABLED == cyPmBackup.ilo100kEnable)
1430   1          {
1431   2              /* Enable 100kHz ILO */
1432   2              CyILO_Start100K();
1433   2          }
1434   1      
1435   1          /* Restore ILO power mode */
1436   1          (void) CyILO_SetPowerMode(cyPmBackup.iloPowerMode);
1437   1      
1438   1      
1439   1          if(CY_PM_DISABLED == cyPmBackup.slpTrBypass)
1440   1          {
1441   2              /* Enable the sleep regulator */
1442   2              CY_PM_PWRSYS_SLP_TR_REG &= ((uint8)(~CY_PM_PWRSYS_SLP_TR_BYPASS));
1443   2          }
1444   1      
1445   1      
1446   1          /***************************************************************************
1447   1          * Restore the power mode wakeup trim registers
1448   1          ***************************************************************************/
1449   1          CY_PM_PWRSYS_WAKE_TR0_REG = cyPmBackup.wakeupTrim0;
1450   1          CY_PM_PWRSYS_WAKE_TR1_REG = cyPmBackup.wakeupTrim1;
1451   1      
1452   1          #if(CY_PSOC5)
                      CY_PM_PWRSYS_WAKE_TR3_REG = cyPmBackup.wakeupTrim3;
                  #endif  /* (CY_PSOC5) */    
1455   1      }
1456          
1457          
1458          /*******************************************************************************
1459          * Function Name: CyPmCtwSetInterval
1460          ****************************************************************************//**
1461          *
1462          *  Performs the CTW configuration:
1463          *  - Disables the CTW interrupt
1464          *  - Enables 1 kHz ILO
1465          *  - Sets a new CTW interval
1466          *
1467          *  \param ctwInterval: the CTW interval to be set.
1468          *
1469          * \sideeffect
1470          *  Enables ILO 1 KHz clock and leaves it enabled.
1471          *
1472          *******************************************************************************/
1473          void CyPmCtwSetInterval(uint8 ctwInterval) 
1474          {
C51 COMPILER V9.51   CYPM                                                                  03/16/2018 17:06:28 PAGE 25  

1475   1          /* Disable CTW interrupt enable */
1476   1          CY_PM_TW_CFG2_REG &= ((uint8)(~CY_PM_CTW_IE));
1477   1      
1478   1          /* Enable 1kHz ILO (required for CTW operation) */
1479   1          CyILO_Start1K();
1480   1      
1481   1          /* Interval could be set only while CTW is disabled */
1482   1          if(0u != (CY_PM_TW_CFG2_REG & CY_PM_CTW_EN))
1483   1          {
1484   2              /* Set CTW interval if needed */
1485   2              if(CY_PM_TW_CFG1_REG != ctwInterval)
1486   2              {
1487   3                  /* Disable the CTW, set new CTW interval and enable it again */
1488   3                  CY_PM_TW_CFG2_REG &= ((uint8)(~CY_PM_CTW_EN));
1489   3                  CY_PM_TW_CFG1_REG = ctwInterval;
1490   3                  CY_PM_TW_CFG2_REG |= CY_PM_CTW_EN;
1491   3              }   /* Required interval is already set */
1492   2          }
1493   1          else
1494   1          {
1495   2              /* Set CTW interval if needed */
1496   2              if(CY_PM_TW_CFG1_REG != ctwInterval)
1497   2              {
1498   3                  /* Set new CTW interval. Could be changed if CTW is disabled */
1499   3                  CY_PM_TW_CFG1_REG = ctwInterval;
1500   3              }   /* Required interval is already set */
1501   2      
1502   2              /* Enable CTW */
1503   2              CY_PM_TW_CFG2_REG |= CY_PM_CTW_EN;
1504   2          }
1505   1      }
1506          
1507          
1508          /*******************************************************************************
1509          * Function Name: CyPmOppsSet
1510          ****************************************************************************//**
1511          *
1512          *  Performs 1PPS configuration:
1513          *  - Starts 32 KHz XTAL
1514          *  - Disables 1PPS interrupts
1515          *  - Enables 1PPS
1516          *
1517          *******************************************************************************/
1518          void CyPmOppsSet(void) 
1519          {
1520   1          /* Enable 32kHz XTAL if needed */
1521   1          if(0u == (CY_PM_SLOWCLK_X32_CR_REG & CY_PM_X32_CR_X32EN))
1522   1          {
1523   2              /* Enable 32kHz XTAL */
1524   2              CyXTAL_32KHZ_Start();
1525   2          }
1526   1      
1527   1          /* Disable 1PPS interrupt enable */
1528   1          CY_PM_TW_CFG2_REG &= ((uint8)(~CY_PM_1PPS_IE));
1529   1      
1530   1          /* Enable 1PPS operation */
1531   1          CY_PM_TW_CFG2_REG |= CY_PM_1PPS_EN;
1532   1      }
1533          
1534          
1535          /*******************************************************************************
1536          * Function Name: CyPmFtwSetInterval
C51 COMPILER V9.51   CYPM                                                                  03/16/2018 17:06:28 PAGE 26  

1537          ****************************************************************************//**
1538          *
1539          *  Performs the FTW configuration:
1540          *  - Disables the FTW interrupt
1541          *  - Enables 100 kHz ILO
1542          *  - Sets a new FTW interval.
1543          *
1544          *  \param ftwInterval The FTW counter interval.
1545          *
1546          * \sideeffect
1547          *  Enables the ILO 100 KHz clock and leaves it enabled.
1548          *
1549          *******************************************************************************/
1550          void CyPmFtwSetInterval(uint8 ftwInterval) 
1551          {
1552   1          /* Disable FTW interrupt enable */
1553   1          CY_PM_TW_CFG2_REG &= ((uint8)(~CY_PM_FTW_IE));
1554   1      
1555   1          /* Enable 100kHz ILO */
1556   1          CyILO_Start100K();
1557   1      
1558   1          /* Interval could be set only while FTW is disabled */
1559   1          if(0u != (CY_PM_TW_CFG2_REG & CY_PM_FTW_EN))
1560   1          {
1561   2              /* Disable FTW, set new FTW interval if needed and enable it again */
1562   2              if(CY_PM_TW_CFG0_REG != ftwInterval)
1563   2              {
1564   3                  /* Disable CTW, set new CTW interval and enable it again */
1565   3                  CY_PM_TW_CFG2_REG &= ((uint8)(~CY_PM_FTW_EN));
1566   3                  CY_PM_TW_CFG0_REG = ftwInterval;
1567   3                  CY_PM_TW_CFG2_REG |= CY_PM_FTW_EN;
1568   3              }   /* Required interval is already set */
1569   2          }
1570   1          else
1571   1          {
1572   2              /* Set new FTW counter interval if needed. FTW is disabled. */
1573   2              if(CY_PM_TW_CFG0_REG != ftwInterval)
1574   2              {
1575   3                  /* Set new CTW interval. Could be changed if CTW is disabled */
1576   3                  CY_PM_TW_CFG0_REG = ftwInterval;
1577   3              }   /* Required interval is already set */
1578   2      
1579   2              /* Enable FTW */
1580   2              CY_PM_TW_CFG2_REG |= CY_PM_FTW_EN;
1581   2          }
1582   1      }
1583          
1584          
1585          /*******************************************************************************
1586          * Function Name: CyPmHibSlpSaveSet
1587          ****************************************************************************//**
1588          *
1589          *  This API is used for preparing the device for the Sleep and Hibernate low
1590          *  power modes entry:
1591          *  - Saves the COMP, VIDAC, DSM, and SAR routing connections (PSoC 5)
1592          *  - Saves the SC/CT routing connections (PSoC 3/5/5LP)
1593          *  - Disables the Serial Wire Viewer (SWV) (PSoC 3)
1594          *  - Saves the boost reference selection and sets it to internal
1595          *
1596          * Reentrant:
1597          *  No
1598          *
C51 COMPILER V9.51   CYPM                                                                  03/16/2018 17:06:28 PAGE 27  

1599          *******************************************************************************/
1600          static void CyPmHibSlpSaveSet(void) 
1601          {
1602   1          /* Save SC/CT routing registers */
1603   1          cyPmBackup.scctData[0u]   = CY_GET_REG8(CYREG_SC0_SW0 );
1604   1          cyPmBackup.scctData[1u]   = CY_GET_REG8(CYREG_SC0_SW2 );
1605   1          cyPmBackup.scctData[2u]   = CY_GET_REG8(CYREG_SC0_SW3 );
1606   1          cyPmBackup.scctData[3u]   = CY_GET_REG8(CYREG_SC0_SW4 );
1607   1          cyPmBackup.scctData[4u]   = CY_GET_REG8(CYREG_SC0_SW6 );
1608   1          cyPmBackup.scctData[5u]   = CY_GET_REG8(CYREG_SC0_SW8 );
1609   1          cyPmBackup.scctData[6u]   = CY_GET_REG8(CYREG_SC0_SW10);
1610   1      
1611   1          cyPmBackup.scctData[7u]   = CY_GET_REG8(CYREG_SC1_SW0 );
1612   1          cyPmBackup.scctData[8u]   = CY_GET_REG8(CYREG_SC1_SW2 );
1613   1          cyPmBackup.scctData[9u]   = CY_GET_REG8(CYREG_SC1_SW3 );
1614   1          cyPmBackup.scctData[10u]  = CY_GET_REG8(CYREG_SC1_SW4 );
1615   1          cyPmBackup.scctData[11u]  = CY_GET_REG8(CYREG_SC1_SW6 );
1616   1          cyPmBackup.scctData[12u]  = CY_GET_REG8(CYREG_SC1_SW8 );
1617   1          cyPmBackup.scctData[13u]  = CY_GET_REG8(CYREG_SC1_SW10);
1618   1      
1619   1          cyPmBackup.scctData[14u]  = CY_GET_REG8(CYREG_SC2_SW0 );
1620   1          cyPmBackup.scctData[15u]  = CY_GET_REG8(CYREG_SC2_SW2 );
1621   1          cyPmBackup.scctData[16u]  = CY_GET_REG8(CYREG_SC2_SW3 );
1622   1          cyPmBackup.scctData[17u]  = CY_GET_REG8(CYREG_SC2_SW4 );
1623   1          cyPmBackup.scctData[18u]  = CY_GET_REG8(CYREG_SC2_SW6 );
1624   1          cyPmBackup.scctData[19u]  = CY_GET_REG8(CYREG_SC2_SW8 );
1625   1          cyPmBackup.scctData[20u]  = CY_GET_REG8(CYREG_SC2_SW10);
1626   1      
1627   1          cyPmBackup.scctData[21u]  = CY_GET_REG8(CYREG_SC3_SW0 );
1628   1          cyPmBackup.scctData[22u]  = CY_GET_REG8(CYREG_SC3_SW2 );
1629   1          cyPmBackup.scctData[23u]  = CY_GET_REG8(CYREG_SC3_SW3 );
1630   1          cyPmBackup.scctData[24u]  = CY_GET_REG8(CYREG_SC3_SW4 );
1631   1          cyPmBackup.scctData[25u]  = CY_GET_REG8(CYREG_SC3_SW6 );
1632   1          cyPmBackup.scctData[26u]  = CY_GET_REG8(CYREG_SC3_SW8 );
1633   1          cyPmBackup.scctData[27u]  = CY_GET_REG8(CYREG_SC3_SW10);
1634   1      
1635   1          CY_SET_REG8(CYREG_SC0_SW0 , 0u);
1636   1          CY_SET_REG8(CYREG_SC0_SW2 , 0u);
1637   1          CY_SET_REG8(CYREG_SC0_SW3 , 0u);
1638   1          CY_SET_REG8(CYREG_SC0_SW4 , 0u);
1639   1          CY_SET_REG8(CYREG_SC0_SW6 , 0u);
1640   1          CY_SET_REG8(CYREG_SC0_SW8 , 0u);
1641   1          CY_SET_REG8(CYREG_SC0_SW10, 0u);
1642   1      
1643   1          CY_SET_REG8(CYREG_SC1_SW0 , 0u);
1644   1          CY_SET_REG8(CYREG_SC1_SW2 , 0u);
1645   1          CY_SET_REG8(CYREG_SC1_SW3 , 0u);
1646   1          CY_SET_REG8(CYREG_SC1_SW4 , 0u);
1647   1          CY_SET_REG8(CYREG_SC1_SW6 , 0u);
1648   1          CY_SET_REG8(CYREG_SC1_SW8 , 0u);
1649   1          CY_SET_REG8(CYREG_SC1_SW10, 0u);
1650   1      
1651   1          CY_SET_REG8(CYREG_SC2_SW0 , 0u);
1652   1          CY_SET_REG8(CYREG_SC2_SW2 , 0u);
1653   1          CY_SET_REG8(CYREG_SC2_SW3 , 0u);
1654   1          CY_SET_REG8(CYREG_SC2_SW4 , 0u);
1655   1          CY_SET_REG8(CYREG_SC2_SW6 , 0u);
1656   1          CY_SET_REG8(CYREG_SC2_SW8 , 0u);
1657   1          CY_SET_REG8(CYREG_SC2_SW10, 0u);
1658   1      
1659   1          CY_SET_REG8(CYREG_SC3_SW0 , 0u);
1660   1          CY_SET_REG8(CYREG_SC3_SW2 , 0u);
C51 COMPILER V9.51   CYPM                                                                  03/16/2018 17:06:28 PAGE 28  

1661   1          CY_SET_REG8(CYREG_SC3_SW3 , 0u);
1662   1          CY_SET_REG8(CYREG_SC3_SW4 , 0u);
1663   1          CY_SET_REG8(CYREG_SC3_SW6 , 0u);
1664   1          CY_SET_REG8(CYREG_SC3_SW8 , 0u);
1665   1          CY_SET_REG8(CYREG_SC3_SW10, 0u);
1666   1      
1667   1      
1668   1          #if(CY_PSOC3)
1669   1      
1670   1              /* Serial Wire Viewer (SWV) workaround */
1671   1      
1672   1              /* Disable SWV before entering low power mode */
1673   1              if(0u != (CY_PM_MLOGIC_DBG_REG & CY_PM_MLOGIC_DBG_SWV_CLK_EN))
1674   1              {
1675   2                  /* Save SWV clock enabled state */
1676   2                  cyPmBackup.swvClkEnabled = CY_PM_ENABLED;
1677   2      
1678   2                  /* Save current ports drive mode settings */
1679   2                  cyPmBackup.prt1Dm = CY_PM_PRT1_PC3_REG & ((uint8)(~CY_PM_PRT1_PC3_DM_MASK));
1680   2      
1681   2                  /* Set drive mode to strong output */
1682   2                  CY_PM_PRT1_PC3_REG = (CY_PM_PRT1_PC3_REG & CY_PM_PRT1_PC3_DM_MASK) |
1683   2                                      CY_PM_PRT1_PC3_DM_STRONG;
1684   2      
1685   2                  /* Disable SWV clocks */
1686   2                  CY_PM_MLOGIC_DBG_REG &= ((uint8)(~CY_PM_MLOGIC_DBG_SWV_CLK_EN));
1687   2              }
1688   1              else
1689   1              {
1690   2                  /* Save SWV clock disabled state */
1691   2                  cyPmBackup.swvClkEnabled = CY_PM_DISABLED;
1692   2              }
1693   1      
1694   1          #endif  /* (CY_PSOC3) */
1695   1      
1696   1      
1697   1          /***************************************************************************
1698   1          * Save boost reference and set it to boost's internal by clearing the bit.
1699   1          * External (chip bandgap) reference is not available in Sleep and Hibernate.
1700   1          ***************************************************************************/
1701   1          if(0u != (CY_PM_BOOST_CR2_REG & CY_PM_BOOST_CR2_EREFSEL_EXT))
1702   1          {
1703   2              cyPmBackup.boostRefExt = CY_PM_ENABLED;
1704   2              CY_PM_BOOST_CR2_REG &= ((uint8)(~CY_PM_BOOST_CR2_EREFSEL_EXT));
1705   2          }
1706   1          else
1707   1          {
1708   2              cyPmBackup.boostRefExt = CY_PM_DISABLED;
1709   2          }
1710   1      }
1711          
1712          
1713          /*******************************************************************************
1714          * Function Name: CyPmHibSlpRestore
1715          ****************************************************************************//**
1716          *
1717          *  This API is used for restoring the device configurations after wakeup from
1718          *  the Sleep and Hibernate low power modes:
1719          *  - Restores the SC/CT routing connections
1720          *  - Restores the enable state of the Serial Wire Viewer (SWV) (PSoC 3)
1721          *  - Restores the  boost reference selection
1722          *
C51 COMPILER V9.51   CYPM                                                                  03/16/2018 17:06:28 PAGE 29  

1723          *******************************************************************************/
1724          static void CyPmHibSlpRestore(void) 
1725          {
1726   1          /* Restore SC/CT routing registers */
1727   1          CY_SET_REG8(CYREG_SC0_SW0 , cyPmBackup.scctData[0u] );
1728   1          CY_SET_REG8(CYREG_SC0_SW2 , cyPmBackup.scctData[1u] );
1729   1          CY_SET_REG8(CYREG_SC0_SW3 , cyPmBackup.scctData[2u] );
1730   1          CY_SET_REG8(CYREG_SC0_SW4 , cyPmBackup.scctData[3u] );
1731   1          CY_SET_REG8(CYREG_SC0_SW6 , cyPmBackup.scctData[4u] );
1732   1          CY_SET_REG8(CYREG_SC0_SW8 , cyPmBackup.scctData[5u] );
1733   1          CY_SET_REG8(CYREG_SC0_SW10, cyPmBackup.scctData[6u] );
1734   1      
1735   1          CY_SET_REG8(CYREG_SC1_SW0 , cyPmBackup.scctData[7u] );
1736   1          CY_SET_REG8(CYREG_SC1_SW2 , cyPmBackup.scctData[8u] );
1737   1          CY_SET_REG8(CYREG_SC1_SW3 , cyPmBackup.scctData[9u] );
1738   1          CY_SET_REG8(CYREG_SC1_SW4 , cyPmBackup.scctData[10u]);
1739   1          CY_SET_REG8(CYREG_SC1_SW6 , cyPmBackup.scctData[11u]);
1740   1          CY_SET_REG8(CYREG_SC1_SW8 , cyPmBackup.scctData[12u]);
1741   1          CY_SET_REG8(CYREG_SC1_SW10, cyPmBackup.scctData[13u]);
1742   1      
1743   1          CY_SET_REG8(CYREG_SC2_SW0 , cyPmBackup.scctData[14u]);
1744   1          CY_SET_REG8(CYREG_SC2_SW2 , cyPmBackup.scctData[15u]);
1745   1          CY_SET_REG8(CYREG_SC2_SW3 , cyPmBackup.scctData[16u]);
1746   1          CY_SET_REG8(CYREG_SC2_SW4 , cyPmBackup.scctData[17u]);
1747   1          CY_SET_REG8(CYREG_SC2_SW6 , cyPmBackup.scctData[18u]);
1748   1          CY_SET_REG8(CYREG_SC2_SW8 , cyPmBackup.scctData[19u]);
1749   1          CY_SET_REG8(CYREG_SC2_SW10, cyPmBackup.scctData[20u]);
1750   1      
1751   1          CY_SET_REG8(CYREG_SC3_SW0 , cyPmBackup.scctData[21u]);
1752   1          CY_SET_REG8(CYREG_SC3_SW2 , cyPmBackup.scctData[22u]);
1753   1          CY_SET_REG8(CYREG_SC3_SW3 , cyPmBackup.scctData[23u]);
1754   1          CY_SET_REG8(CYREG_SC3_SW4 , cyPmBackup.scctData[24u]);
1755   1          CY_SET_REG8(CYREG_SC3_SW6 , cyPmBackup.scctData[25u]);
1756   1          CY_SET_REG8(CYREG_SC3_SW8 , cyPmBackup.scctData[26u]);
1757   1          CY_SET_REG8(CYREG_SC3_SW10, cyPmBackup.scctData[27u]);
1758   1      
1759   1      
1760   1          #if(CY_PSOC3)
1761   1      
1762   1              /* Serial Wire Viewer (SWV) workaround */
1763   1              if(CY_PM_ENABLED == cyPmBackup.swvClkEnabled)
1764   1              {
1765   2                  /* Restore ports drive mode */
1766   2                  CY_PM_PRT1_PC3_REG = (CY_PM_PRT1_PC3_REG & CY_PM_PRT1_PC3_DM_MASK) |
1767   2                                          cyPmBackup.prt1Dm;
1768   2      
1769   2                  /* Enable SWV clocks */
1770   2                  CY_PM_MLOGIC_DBG_REG |= CY_PM_MLOGIC_DBG_SWV_CLK_EN;
1771   2              }
1772   1      
1773   1          #endif /* (CY_PSOC3) */
1774   1      
1775   1      
1776   1          /* Restore boost reference */
1777   1          if(CY_PM_ENABLED == cyPmBackup.boostRefExt)
1778   1          {
1779   2              CY_PM_BOOST_CR2_REG |= CY_PM_BOOST_CR2_EREFSEL_EXT;
1780   2          }
1781   1      }
1782          
1783          
1784          /*******************************************************************************
C51 COMPILER V9.51   CYPM                                                                  03/16/2018 17:06:28 PAGE 30  

1785          * Function Name: CyPmHviLviSaveDisable
1786          ****************************************************************************//**
1787          *
1788          *  Saves analog and digital LVI and HVI configuration and disables them.
1789          *
1790          * Reentrant:
1791          *  No
1792          *
1793          *******************************************************************************/
1794          static void CyPmHviLviSaveDisable(void) 
1795          {
1796   1          if(0u != (CY_VD_LVI_HVI_CONTROL_REG & CY_VD_LVID_EN))
1797   1          {
1798   2              cyPmBackup.lvidEn = CY_PM_ENABLED;
1799   2              cyPmBackup.lvidTrip = CY_VD_LVI_TRIP_REG & CY_VD_LVI_TRIP_LVID_MASK;
1800   2      
1801   2              /* Save state of reset device at specified Vddd threshold */
1802   2              cyPmBackup.lvidRst = (0u == (CY_VD_PRES_CONTROL_REG & CY_VD_PRESD_EN)) ? \
1803   2                                   CY_PM_DISABLED : CY_PM_ENABLED;
1804   2      
1805   2              CyVdLvDigitDisable();
1806   2          }
1807   1          else
1808   1          {
1809   2              cyPmBackup.lvidEn = CY_PM_DISABLED;
1810   2          }
1811   1      
1812   1          if(0u != (CY_VD_LVI_HVI_CONTROL_REG & CY_VD_LVIA_EN))
1813   1          {
1814   2              cyPmBackup.lviaEn = CY_PM_ENABLED;
1815   2              cyPmBackup.lviaTrip = CY_VD_LVI_TRIP_REG >> 4u;
1816   2      
1817   2              /* Save state of reset device at specified Vdda threshold */
1818   2              cyPmBackup.lviaRst = (0u == (CY_VD_PRES_CONTROL_REG & CY_VD_PRESA_EN)) ? \
1819   2                                   CY_PM_DISABLED : CY_PM_ENABLED;
1820   2      
1821   2              CyVdLvAnalogDisable();
1822   2          }
1823   1          else
1824   1          {
1825   2              cyPmBackup.lviaEn = CY_PM_DISABLED;
1826   2          }
1827   1      
1828   1          if(0u != (CY_VD_LVI_HVI_CONTROL_REG & CY_VD_HVIA_EN))
1829   1          {
1830   2              cyPmBackup.hviaEn = CY_PM_ENABLED;
1831   2              CyVdHvAnalogDisable();
1832   2          }
1833   1          else
1834   1          {
1835   2              cyPmBackup.hviaEn = CY_PM_DISABLED;
1836   2          }
1837   1      }
1838          
1839          
1840          /*******************************************************************************
1841          * Function Name: CyPmHviLviRestore
1842          ****************************************************************************//**
1843          *
1844          *  Restores the analog and digital LVI and HVI configuration.
1845          *
1846          * Reentrant:
C51 COMPILER V9.51   CYPM                                                                  03/16/2018 17:06:28 PAGE 31  

1847          *  No
1848          *
1849          *******************************************************************************/
1850          static void CyPmHviLviRestore(void) 
1851          {
1852   1          /* Restore LVI/HVI configuration */
1853   1          if(CY_PM_ENABLED == cyPmBackup.lvidEn)
1854   1          {
1855   2              CyVdLvDigitEnable(cyPmBackup.lvidRst, cyPmBackup.lvidTrip);
1856   2          }
1857   1      
1858   1          if(CY_PM_ENABLED == cyPmBackup.lviaEn)
1859   1          {
1860   2              CyVdLvAnalogEnable(cyPmBackup.lviaRst, cyPmBackup.lviaTrip);
1861   2          }
1862   1      
1863   1          if(CY_PM_ENABLED == cyPmBackup.hviaEn)
1864   1          {
1865   2              CyVdHvAnalogEnable();
1866   2          }
1867   1      }
1868          
1869          
1870          /* [] END OF FILE */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4310    ----
   CONSTANT SIZE    =     14    ----
   XDATA SIZE       =     88    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
